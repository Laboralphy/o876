{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/Emitter.js","webpack:///./src/Rainbow.js","webpack:///./src/Random.js","webpack:///./src/SpellBook.js","webpack:///./src/algorithms/Astar/Astar.js","webpack:///./src/algorithms/Astar/Nood.js","webpack:///./src/algorithms/Astar/NoodList.js","webpack:///./src/algorithms/Astar/index.js","webpack:///./src/algorithms/Bresenham.js","webpack:///./src/algorithms/Easing.js","webpack:///./src/algorithms/Perlin.js","webpack:///./src/algorithms/SquareSpiral.js","webpack:///./src/algorithms/index.js","webpack:///./src/collider/Collider.js","webpack:///./src/collider/Dummy.js","webpack:///./src/collider/Sector.js","webpack:///./src/collider/index.js","webpack:///./src/geometry/Helper.js","webpack:///./src/geometry/Point.js","webpack:///./src/geometry/Vector.js","webpack:///./src/geometry/index.js","webpack:///./src/index.js","webpack:///./src/indexWeb.js","webpack:///./src/structures/Grid.js","webpack:///./src/structures/index.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;AClFA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,EAAE;AACrB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB,qBAAqB;AACrB,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB,qBAAqB;AACrB,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB,wBAAwB;AACxB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB,wBAAwB;AACxB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB,wBAAwB;AACxB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;;;;AC7HA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA,0CAA0C,IAAI,aAAa,IAAI,aAAa,IAAI;AAChF;AACA,cAAc;AACd,MAAM;AACN,wCAAwC,IAAI,aAAa,IAAI,aAAa,IAAI;AAC9E;AACA,eAAe;AACf,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,K;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnWA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC,mBAAmB,OAAO;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,6BAA6B;AAC7B,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,mCAAmC,GAAG;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC5IA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,iBAAiB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,iBAAiB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;AAGA,2B;;;;;;;;;;;ACpKA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,UAAU,+BAA+B,aAAa;AACtD,WAAW,gCAAgC,aAAa;AACxD,WAAW,gCAAgC,aAAa;AACxD,eAAe,oCAAoC,aAAa;;AAEhE;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,mBAAmB,OAAO;AAC1B,gBAAgB;AAChB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB;AACnB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB;AAChB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB;AAChB,aAAa;AACb;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxQA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;AClBA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd,cAAc;AACd,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd,cAAc;AACd,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd,cAAc;AACd,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd,cAAc;AACd,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,E;;;;;;;;;;;ACtFA;;AAEA;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,aAAa;AAC7E;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;;;;AC/KA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,U;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA;;AAEA;AACA;AACA;AACA;;AAEA,aAAa,OAAO;AACpB;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA,sCAAsC,cAAc;AACpD;AACA;;AAEA,cAAc,OAAO;AACrB;AACA,eAAe,OAAO;AACtB;AACA;AACA,I;AACA;AACA,aAAa,OAAO;AACpB;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,c;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6CAA6C,0BAA0B,EAAE;AACzE;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,MAAM;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;;AAEA,wB;;;;;;;;;;;ACvVA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gBAAgB;AACtC,uBAAuB,gBAAgB;AACvC;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9DA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,aAAa;AACb;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;;;;ACpHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,E;;;;;;;;;;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;;;;;;;;;;;;;AChDA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,E;;;;;;;;;;;ACRA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe;AACf,eAAe,OAAO;AACtB,eAAe;AACf,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB,kBAAkB;AAClB,kBAAkB;AAClB,kBAAkB;AAClB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,E;;;;;;;;;;;AC3CA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd,aAAa;AACb;AACA;AACA;AACA;AACA,E;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd,cAAc;AACd;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;;;;ACjJA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,E;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;;;;ACtBA;;AAEA;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU,+BAA+B,aAAa;AACtD,WAAW,gCAAgC,aAAa;AACxD,WAAW,gCAAgC,aAAa;AACxD,eAAe,oCAAoC,aAAa;;;AAGhE;AACA;AACA,mBAAmB;AACnB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB;AACnB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB;AACnB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd,cAAc;AACd;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA,cAAc,OAAO;AACrB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB,mBAAmB;AACnB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/GA;;AAEA;AACA;AACA,E","file":"libo876web.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/indexWeb.js\");\n","/**\n * Created by ralphy on 07/09/17.\n */\n\nconst SB = require('./SpellBook');\n/**\n * this class is similar to the node.js Emitter system\n * it emits events\n * client instances may instanciate this class and call methods such as\n * .on  to defines an event handler\n * .off to undefined an event handler\n * .one to define a \"one triggered\" handler\n * .trigger to cast an event\n *\n * Only usefull in javascript, as node.js is provided with the \"events\" module.\n */\n\n\nmodule.exports = class Emitter {\n    constructor() {\n        this._oEventHandlers = {};\n    }\n\n    /**\n\t * triggers an event\n\t * @param sEvent {string} event name\n\t * @param params {*} any parameter that will transmitted to the handler\n     * @return {*}\n     */\n    trigger(sEvent, params) {\n        let aArgs = SB.array(arguments);\n        aArgs.shift();\n        let eh = this._oEventHandlers;\n        if (sEvent in eh) {\n\t\t\teh[sEvent].one.forEach(f => f.apply(this, aArgs));\n\t\t\teh[sEvent].one = [];\n            eh[sEvent].on.forEach(f => f.apply(this, aArgs));\n        }\n\t\treturn this;\n    }\n\n    /**\n\t * A private helper to define a handler\n     * @param sEvent {string}\n     * @param sType {string}\n     * @param pHandler {function}\n     * @private\n     */\n\t_define(sEvent, sType, pHandler) {\n\t\tlet eh = this._oEventHandlers;\n\t\tif (!(sEvent in eh)) {\n\t\t\teh[sEvent] = {\n\t\t\t    on: [],\n                one: []\n            };\n\t\t}\n\t\teh[sEvent][sType].push(pHandler);\n\t}\n\n    /**\n\t * a private method to undefined an event\n     * @param sEvent {string}\n     * @param sType {string}\n     * @param pHandler ({function})\n     * @private\n     */\n\t_undefine(sEvent, sType, pHandler) {\n\t\tlet eh = this._oEventHandlers;\n\t\tif (!(sEvent in eh)) {\n\t\t\treturn;\n\t\t}\n\t\teh = eh[sEvent];\n\t\tif (!(sType in eh)) {\n\t\t\treturn;\n\t\t}\n\t\tif (pHandler) {\n\t\t\teh[sType] = eh[sType].filter(h => h !== pHandler);\n        } else {\n\t\t\teh[sType] = [];\n        }\n\t}\n\n    /**\n\t * Defines an event handler, that will be invoked each time the event is triggered\n     * @param sEvent {string}\n     * @param pHandler {function}\n     * @return {Emitter}\n     */\n\ton(sEvent, pHandler) {\n\t\tthis._define(sEvent, 'on', pHandler);\n\t\treturn this;\n\t}\n\n    /**\n     * Defines an event handler, that will be invoked only the next time\n\t * the event will be triggered\n     * @param sEvent {string}\n     * @param pHandler {function}\n     * @return {Emitter}\n     */\n\tone(sEvent, pHandler) {\n\t\tthis._define(sEvent, 'one', pHandler);\n\t\treturn this;\n\t}\n\n    /**\n\t * unload event handlers\n     * @param sEvent {string}\n     * @param pHandler {function}\n     * @return {Emitter}\n     */\n\toff(sEvent, pHandler) {\n        switch (SB.typeMap(arguments)) {\n            case 's': // turn off handler\n\t\t\t\tthis._undefine(sEvent, 'on');\n\t\t\t\tthis._undefine(sEvent, 'one');\n\t\t\t\tbreak;\n\n            case 'sf':\n\t\t\t\tthis._undefine(sEvent, 'on', pHandler);\n\t\t\t\tthis._undefine(sEvent, 'one', pHandler);\n\t\t\t\tbreak;\n        }\n\t\treturn this;\n\t}\n};","/**\n * @class O876.Rainbow\n * Rainbow - Color Code Convertor Boîte à outil graphique\n * O876 raycaster project\n * 2012-01-01 Raphaël Marandet\n * good to GIT\n */\n\nconst COLORS = {\n\taliceblue : '#F0F8FF',\n\tantiquewhite : '#FAEBD7',\n\taqua : '#00FFFF',\n\taquamarine : '#7FFFD4',\n\tazure : '#F0FFFF',\n\tbeige : '#F5F5DC',\n\tbisque : '#FFE4C4',\n\tblack : '#000000',\n\tblanchedalmond : '#FFEBCD',\n\tblue : '#0000FF',\n\tblueviolet : '#8A2BE2',\n\tbrown : '#A52A2A',\n\tburlywood : '#DEB887',\n\tcadetblue : '#5F9EA0',\n\tchartreuse : '#7FFF00',\n\tchocolate : '#D2691E',\n\tcoral : '#FF7F50',\n\tcornflowerblue : '#6495ED',\n\tcornsilk : '#FFF8DC',\n\tcrimson : '#DC143C',\n\tcyan : '#00FFFF',\n\tdarkblue : '#00008B',\n\tdarkcyan : '#008B8B',\n\tdarkgoldenrod : '#B8860B',\n\tdarkgray : '#A9A9A9',\n\tdarkgrey : '#A9A9A9',\n\tdarkgreen : '#006400',\n\tdarkkhaki : '#BDB76B',\n\tdarkmagenta : '#8B008B',\n\tdarkolivegreen : '#556B2F',\n\tdarkorange : '#FF8C00',\n\tdarkorchid : '#9932CC',\n\tdarkred : '#8B0000',\n\tdarksalmon : '#E9967A',\n\tdarkseagreen : '#8FBC8F',\n\tdarkslateblue : '#483D8B',\n\tdarkslategray : '#2F4F4F',\n\tdarkslategrey : '#2F4F4F',\n\tdarkturquoise : '#00CED1',\n\tdarkviolet : '#9400D3',\n\tdeeppink : '#FF1493',\n\tdeepskyblue : '#00BFFF',\n\tdimgray : '#696969',\n\tdimgrey : '#696969',\n\tdodgerblue : '#1E90FF',\n\tfirebrick : '#B22222',\n\tfloralwhite : '#FFFAF0',\n\tforestgreen : '#228B22',\n\tfuchsia : '#FF00FF',\n\tgainsboro : '#DCDCDC',\n\tghostwhite : '#F8F8FF',\n\tgold : '#FFD700',\n\tgoldenrod : '#DAA520',\n\tgray : '#808080',\n\tgrey : '#808080',\n\tgreen : '#008000',\n\tgreenyellow : '#ADFF2F',\n\thoneydew : '#F0FFF0',\n\thotpink : '#FF69B4',\n\tindianred  : '#CD5C5C',\n\tindigo  : '#4B0082',\n\tivory : '#FFFFF0',\n\tkhaki : '#F0E68C',\n\tlavender : '#E6E6FA',\n\tlavenderblush : '#FFF0F5',\n\tlawngreen : '#7CFC00',\n\tlemonchiffon : '#FFFACD',\n\tlightblue : '#ADD8E6',\n\tlightcoral : '#F08080',\n\tlightcyan : '#E0FFFF',\n\tlightgoldenrodyellow : '#FAFAD2',\n\tlightgray : '#D3D3D3',\n\tlightgrey : '#D3D3D3',\n\tlightgreen : '#90EE90',\n\tlightpink : '#FFB6C1',\n\tlightsalmon : '#FFA07A',\n\tlightseagreen : '#20B2AA',\n\tlightskyblue : '#87CEFA',\n\tlightslategray : '#778899',\n\tlightslategrey : '#778899',\n\tlightsteelblue : '#B0C4DE',\n\tlightyellow : '#FFFFE0',\n\tlime : '#00FF00',\n\tlimegreen : '#32CD32',\n\tlinen : '#FAF0E6',\n\tmagenta : '#FF00FF',\n\tmaroon : '#800000',\n\tmediumaquamarine : '#66CDAA',\n\tmediumblue : '#0000CD',\n\tmediumorchid : '#BA55D3',\n\tmediumpurple : '#9370DB',\n\tmediumseagreen : '#3CB371',\n\tmediumslateblue : '#7B68EE',\n\tmediumspringgreen : '#00FA9A',\n\tmediumturquoise : '#48D1CC',\n\tmediumvioletred : '#C71585',\n\tmidnightblue : '#191970',\n\tmintcream : '#F5FFFA',\n\tmistyrose : '#FFE4E1',\n\tmoccasin : '#FFE4B5',\n\tnavajowhite : '#FFDEAD',\n\tnavy : '#000080',\n\toldlace : '#FDF5E6',\n\tolive : '#808000',\n\tolivedrab : '#6B8E23',\n\torange : '#FFA500',\n\torangered : '#FF4500',\n\torchid : '#DA70D6',\n\tpalegoldenrod : '#EEE8AA',\n\tpalegreen : '#98FB98',\n\tpaleturquoise : '#AFEEEE',\n\tpalevioletred : '#DB7093',\n\tpapayawhip : '#FFEFD5',\n\tpeachpuff : '#FFDAB9',\n\tperu : '#CD853F',\n\tpink : '#FFC0CB',\n\tplum : '#DDA0DD',\n\tpowderblue : '#B0E0E6',\n\tpurple : '#800080',\n\trebeccapurple : '#663399',\n\tred : '#FF0000',\n\trosybrown : '#BC8F8F',\n\troyalblue : '#4169E1',\n\tsaddlebrown : '#8B4513',\n\tsalmon : '#FA8072',\n\tsandybrown : '#F4A460',\n\tseagreen : '#2E8B57',\n\tseashell : '#FFF5EE',\n\tsienna : '#A0522D',\n\tsilver : '#C0C0C0',\n\tskyblue : '#87CEEB',\n\tslateblue : '#6A5ACD',\n\tslategray : '#708090',\n\tslategrey : '#708090',\n\tsnow : '#FFFAFA',\n\tspringgreen : '#00FF7F',\n\tsteelblue : '#4682B4',\n\ttan : '#D2B48C',\n\tteal : '#008080',\n\tthistle : '#D8BFD8',\n\ttomato : '#FF6347',\n\tturquoise : '#40E0D0',\n\tviolet : '#EE82EE',\n\twheat : '#F5DEB3',\n\twhite : '#FFFFFF',\n\twhitesmoke : '#F5F5F5',\n\tyellow : '#FFFF00',\n\tyellowgreen : '#9ACD32'\n};\n\nmodule.exports = class Rainbow {\n\n\t/** \n\t * Fabrique une chaine de caractère représentant une couleur au format CSS\n\t * @param xData une structure {r: int, g: int, b: int, a: float}\n\t * @return code couleur CSS au format rgb(r, g, b) ou rgba(r, g, b, a)\n\t */\n\tstatic rgba(xData) {\n\t\treturn Rainbow._buildRGBAFromStructure(Rainbow.parse(xData));\n\t}\n\t\n\t/**\n\t * Analyse une valeur d'entrée pour construire une structure avec les \n\t * composantes \"r\", \"g\", \"b\", et eventuellement \"a\".\n\t */ \n\tstatic parse(xData) {\n\t\tif (typeof xData === \"object\") {\n\t\t\treturn xData;\n\t\t} else if (typeof xData === \"number\") {\n\t\t\treturn Rainbow._buildStructureFromInt(xData);\n\t\t} else if (typeof xData === \"string\") {\n\t\t\txData = xData.toLowerCase();\n\t\t\tif (xData in COLORS) {\n\t\t\t\txData = COLORS[xData];\n\t\t\t}\n\t\t\tswitch (xData.length) {\n\t\t\t\tcase 3:\n\t\t\t\t\treturn Rainbow._buildStructureFromString3(xData);\n\t\t\t\t\t\n\t\t\t\tcase 4:\n\t\t\t\t\tif (xData[0] === '#') {\n\t\t\t\t\t\treturn Rainbow._buildStructureFromString3(xData.substr(1));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error('invalid color structure');\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\tcase 6:\n\t\t\t\t\treturn Rainbow._buildStructureFromString6(xData);\n\t\t\t\t\t\n\t\t\t\tcase 7:\n\t\t\t\t\tif (xData[0] === '#') {\n\t\t\t\t\t\treturn Rainbow._buildStructureFromString6(xData.substr(1));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error('invalid color structure');\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\tdefault:\n\t\t\t\t\tlet rx = xData.match(/^rgb\\( *([0-9]{1,3}) *, *([0-9]{1,3}) *, *([0-9]{1,3}) *\\)$/);\n\t\t\t\t\tif (rx) {\n\t\t\t\t\t\treturn {r: rx[1] | 0, g: rx[2] | 0, b: rx[3] | 0};\n\t\t\t\t\t} else {\n\t\t\t\t\t\trx = xData.match(/^rgba\\( *([0-9]{1,3}) *, *([0-9]{1,3}) *, *([0-9]{1,3}) *, *([.0-9]+) *\\)$/);\n\t\t\t\t\t\tif (rx) {\n\t\t\t\t\t\t\treturn {r: rx[1] | 0, g: rx[2] | 0, b: rx[3] | 0, a: parseFloat(rx[4])};\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new Error('invalid color structure ' + xData);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * Génère un spectre entre deux valeurs de couleurs\n\t * La fonction renvoi \n\t */\n\tstatic spectrum(sColor1, sColor2, nSteps) {\n\t\tlet c1 = Rainbow.parse(sColor1);\n\t\tlet c2 = Rainbow.parse(sColor2);\n\t\t\n\t\tlet nSecur = 100;\n\t\t\n\t\tfunction getMedian(x1, x2) {\n\t\t\tif (x1 === undefined) {\n\t\t\t\tthrow new Error('first color is undefined');\n\t\t\t}\n\t\t\tif (x2 === undefined) {\n\t\t\t\tthrow new Error('second color is undefined');\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tr: (x1.r + x2.r) >> 1,\n\t\t\t\tg: (x1.g + x2.g) >> 1,\n\t\t\t\tb: (x1.b + x2.b) >> 1\n\t\t\t};\t\t\t\n\t\t}\n\t\t\n\t\tfunction fillArray(a, x1, x2, n1, n2) {\n\t\t\tlet m = getMedian(x1, x2);\n\t\t\tlet n = (n1 + n2) >> 1;\n\t\t\tif (--nSecur < 0) {\n\t\t\t\treturn a;\n\t\t\t}\n\t\t\tif (Math.abs(n1 - n2) > 1) {\n\t\t\t\tfillArray(a, x1, m, n1, n);\n\t\t\t\tfillArray(a, m, x2, n, n2);\n\t\t\t}\n\t\t\ta[n1] = x1;\n\t\t\ta[n2] = x2;\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\treturn fillArray([], c1, c2, 0, nSteps - 1).map(function(c) {\n\t\t\treturn Rainbow.rgba(c);\n\t\t}, this);\n\t}\n\t\n\t/**\n\t * Generate a gradient\n\t * @param oPalette palette definition\n\t * \n\t * {\n\t * \t\tstart: value,\n\t * \t\tstop1: value,\n\t * \t\tstop2: value,\n\t * \t\t...\n\t * \t\tstopN: value,\n\t * \t\tend: value\n\t * },\n\t * \n\t * example :\n\t * {\n\t * \t\t0: '#00F',\n\t * \t\t50: '#FF0',\n\t * \t\t100: '#F00'\n\t * }\n\t * rappel : une palette d'indices de 0 à 100 dispose de 101 entrée\n\t */\n\tstatic gradient(oPalette) {\n\t\tlet aPalette = [];\n\t\tlet sColor;\n\t\tlet sLastColor = null;\n\t\tlet nPal;\n\t\tlet nLastPal = 0;\n\t\tfor (let iPal in oPalette) {\n\t\t\tnPal = iPal | 0;\n\t\t\tsColor = oPalette[iPal];\n\t\t\tif (sLastColor !== null) {\n\t\t\t\taPalette = aPalette.concat(Rainbow.spectrum(sLastColor, sColor, nPal - nLastPal + 1).slice(1));\n\t\t\t} else {\n\t\t\t\taPalette[nPal] = Rainbow.rgba(sColor);\n\t\t\t}\n\t\t\tsLastColor = sColor;\n\t\t\tnLastPal = nPal;\n\t\t}\n\t\treturn aPalette;\n\t}\n\n\tstatic _buildStructureFromInt(n) {\n\t\tlet r = (n >> 16) & 0xFF;\n\t\tlet g = (n >> 8) & 0xFF;\n\t\tlet b = n & 0xFF;\n\t\treturn {r: r, g: g, b: b};\n\t}\n\t\n\tstatic _buildStructureFromString3(s) {\n\t\tlet r = parseInt('0x' + s[0] + s[0]);\n\t\tlet g = parseInt('0x' + s[1] + s[1]);\n\t\tlet b = parseInt('0x' + s[2] + s[2]);\n\t\treturn {r: r, g: g, b: b};\n\t}\n\n\tstatic _buildStructureFromString6(s) {\n\t\tlet r = parseInt('0x' + s[0] + s[1]);\n\t\tlet g = parseInt('0x' + s[2] + s[3]);\n\t\tlet b = parseInt('0x' + s[4] + s[5]);\n\t\treturn {r: r, g: g, b: b};\n\t}\n\n\tstatic _buildRGBAFromStructure(oData) {\n\t\tlet s1 = 'rgb';\n\t\tlet s2 = oData.r.toString() + ', ' + oData.g.toString() + ', ' + oData.b.toString();\n\t\tif ('a' in oData) {\n\t\t\ts1 += 'a';\n\t\t\ts2 += ', ' + oData.a.toString();\n\t\t}\n\t\treturn s1 + '(' + s2 + ')';\n\t}\n\t\n\tstatic _buildString3FromStructure(oData) {\n\t\tlet sr = ((oData.r >> 4) & 0xF).toString(16);\n\t\tlet sg = ((oData.g >> 4) & 0xF).toString(16);\n\t\tlet sb = ((oData.b >> 4) & 0xF).toString(16);\n\t\treturn sr + sg + sb;\n\t}\n\n\tstatic byte(n) {\n\t\treturn Math.min(255, Math.max(0, n | 0));\n\t}\n\n\tstatic brightness(color, f) {\n\t\tlet c = Rainbow.parse(color);\n\t\tc.r = Rainbow.byte(f * c.r);\n\t\tc.g = Rainbow.byte(f * c.g);\n\t\tc.b = Rainbow.byte(f * c.b);\n\t\treturn c;\n\t}\n};\n","/**\n * @class O876.Random\n * a FALSE random very false...\n * generated random numbers, with seed\n * used for predictable landscape generation\n */\n\nconst SB = require('./SpellBook');\n\nmodule.exports = class Random {\n\n\tconstructor() {\n        this._seed = Math.random();\n\t}\n\n    /**\n\t * Will define a new seed\n     * @param x {number}\n     * @returns {*}\n     */\n\tseed(x) {\n    \treturn SB.prop(this, '_seed', x);\n\t}\n\n    /**\n\t * Return a random generated number using the simple sine-66 function\n     * @returns {number} a number between 0 and 1\n     * @private\n     */\n\t_rand() {\n\t\treturn this._seed = Math.abs(((Math.sin(this._seed) * 1e12) % 1e6) / 1e6);\n\t}\n\n    /**\n\t * returns a random generated number.\n\t * the result will vary according to the given parameter values\n\t * - two integer (a, b) gives a random number between a and b\n\t * - an array gives a random item of this array\n\t * - an object gives a random key of this object\n\t * - no parameter gives a random float value between 0 and 1\n     * @param [a] {number|Array|Object} lower limit\n     * @param [b] {number} upper limit\n     * @returns {*}\n     */\n\trand(a, b) {\n\t\tlet r = this._rand();\n\t\tswitch (typeof a) {\n\t\t\tcase \"undefined\":\n\t\t\t\treturn r;\n\t\t\t\t\n\t\t\tcase \"number\":\n\t\t\t\tif (b === undefined) {\n\t\t\t\t\tb = a - 1;\n\t\t\t\t\ta = 0;\n\t\t\t\t}\n\t\t\t\treturn Math.max(a, Math.min(b, (b - a + 1) * r + a | 0));\n\t\t\t\n\t\t\tcase \"object\":\n\t\t\t\tif (Array.isArray(a)) {\n\t\t\t\t\tif (a.length > 0) {\n\t\t\t\t\t\treturn a[r * a.length | 0];\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn this.rand(Object.keys(a));\n\t\t\t\t}\n\t\t\t\t\n\t\t\tdefault:\n\t\t\t\treturn r;\n\t\t}\n\t}\n\n    /**\n     * This function will randomly pick an item ffrom the given array.\n     * This choice is influenced by a weight.\n     * The weight is either the item value or the result of a function called back with\n     * the item given as parameter.\n     * ex : chooseFate([10, 60, 30]) will give :\n     *  - 0 : 10% of chance\n     *  - 1 : 60% of chance\n     *  - 2 : 40% of chance\n     *\n     * @param aArray {array}\n     * @param pProbFunction {function}\n     * @return {number} the rank of the chosen item\n     */\n    chooseFate(aArray, pProbFunction) {\n        let nSum;\n        if (pProbFunction) {\n            nSum = aArray.reduce((p, c) => Math.max(0, pProbFunction(c)) + p, 0);\n        } else {\n            nSum = aArray.reduce((p, c) => Math.max(0, c) + p, 0);\n        }\n        let nChoice = this.rand(0, nSum - 1);\n        for (let i = 0, l = aArray.length; i < l; ++i) {\n            let ci;\n            if (pProbFunction) {\n                ci = Math.max(0, pProbFunction(aArray[i]));\n            } else {\n                ci = Math.max(0, aArray[i]);\n            }\n            if (nChoice < ci) {\n                return i;\n            }\n            nChoice -= ci;\n        }\n        return null;\n    }\n\n    /**\n     * Shuffles array in place. ES6 version\n     * @param {Array} aArray items The array containing the items.\n     * @param {boolean} bImmutable if true, a new array is built, the provide array remains untouched\n     */\n    shuffle(aArray, bImmutable) {\n        if (bImmutable) {\n            aArray = aArray.slice(0);\n        }\n        for (let i = aArray.length; i; --i) {\n            let j = this.rand(i);\n            [aArray[i - 1], aArray[j]] = [aArray[j], aArray[i - 1]];\n        }\n        return aArray;\n    }\n\n    /**\n     * randomly pick an item from an array\n     * @param aArray {array}\n     * @param bRemove {boolean} if true the item is removed from the array\n     */\n    randPick(aArray, bRemove) {\n        let n = this.rand(aArray.length);\n        let r = aArray[n];\n        if (bRemove) {\n            aArray.splice(n, 1);\n        }\n        return r;\n    }\n\n};\n","/**\n * Created by ralphy on 07/09/17.\n */\n\nclass SpellBook {\n    /**\n     * Turns an array-like-structure into an array (a real one)\n     */\n    static array(subject) {\n        const LENGTH_PROPERTY = 'length';\n        if (Array.isArray(subject)) {\n            return subject;\n        }\n        if (typeof subject === 'object') {\n            // is there a length property ?\n            let bLength = LENGTH_PROPERTY in subject;\n            // extracting keys minus \"length\" property\n            let aKeys = Object\n                .keys(subject)\n                .filter(k => k !== LENGTH_PROPERTY);\n            if (aKeys.some(k => isNaN(k))) {\n                return false;\n            }\n            if ((bLength) && (subject[LENGTH_PROPERTY] !== aKeys.length)) {\n                return false;\n            }\n            if (aKeys\n                .map(k => parseInt(k))\n                .sort((k1, k2) => k1 - k2)\n                .every((k, i) => k === i)) {\n                return bLength\n                    ? Array.prototype.slice.call(subject, 0)\n                    : aKeys.map(k => subject[k]);\n            }\n        }\n        return false;\n    }\n\n    static catsortArray(aInput, {cat, sort = null}) {\n    \tlet oOutput = {};\n    \taInput.forEach(e => {\n    \t\tlet sCat = cat(e);\n    \t\tif (!(sCat in oOutput)) {\n    \t\t\toOutput[sCat] = [];\n\t\t\t}\n\t\t\toOutput[sCat].push(e);\n\t\t});\n    \tif (typeof sort === 'function') {\n\t\t\tfor (let sCat in oOutput) {\n\t\t\t\toOutput[sCat] = oOutput[sCat].sort(sort)\n\t\t\t}\n\t\t}\n\t\treturn oOutput;\n\t}\n\n\t/**\n\t * élimine tout les doubloons de l'array spécifié. Ne modifie par l'array, mais renvoie un nouveau tableau\n\t * @param aArray\n\t * @returns {*}\n\t */\n\tstatic uniqArray(aArray) {\n    \treturn aArray.filter((x, i, a) => a.indexOf(x) === i)\n\t}\n\n    /**\n     * quickly clones an array into a new one\n     * this method is mainly used for turning \"arguments\" pseudo array into a real array\n     * @param a {Array|Object}\n     * @return {Array}\n     */\n    static cloneArray(a) {\n        return Array.prototype.slice.call(a, 0)\n    }\n\n\t/**\n\t * Renvoie le type d'une variable (différencie les Tableau Array des objet}\n\t * @param x {*}\n\t * @returns {string}\n\t */\n\tstatic typeof(x) {\n\t\tlet tx = (typeof x);\n\t\tswitch (tx) {\n\t\t\tcase 'object':\n\t\t\t\tif (x === null) {\n\t\t\t\t\treturn 'u';\n\t\t\t\t} else if (Array.isArray(x)) {\n\t\t\t\t\treturn 'a';\n\t\t\t\t} else {\n\t\t\t\t\treturn 'o';\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn tx.charAt(0);\n\t\t}\n\t}\n\n    /**\n     * maps an array into a string\n     * converting all elements into there \"type\" counterpart.\n     * any number element will be turned into \"n\"\n     * any object element will be turned into \"o\"\n     * this method is used to quickly switch-case an array according to its elements types.\n     *\n     * example : [222, \"abc\", [1,2,3], null, {x: 1.00, y: 3.00}]\n     * will produce : \"nsauo\"\n     * n: number\n     * s: string\n     * b: boolean\n     * o: object\n     * a: real array\n     * f: function\n     * u: undefined / null\n     *\n     * @param aArgs\n     * @return {string}\n     */\n    static typeMap(aArgs) {\n\t\treturn this.cloneArray(aArgs).map(function(x) {\n\t\t\treturn SpellBook.typeof(x);\n\t\t}).join('');\n    }\n\n\t/**\n     * Parse a search string (?variable=value)\n     * @param sSearch {string} as in window.search\n\t * @returns {{}}\n\t */\n\tstatic parseSearch(sSearch) {\n\t\tif (sSearch) {\n\t\t\tlet nQuest = sSearch.indexOf('?');\n\t\t\tif (nQuest >= 0) {\n\t\t\t\tsSearch = sSearch.substr(nQuest + 1);\n\t\t\t} else {\n\t\t\t\treturn {};\n\t\t\t}\n\t\t} else {\n\t\t\tsSearch = window.location.search.substr(1);\n\t\t}\n\t\tlet match,\n\t\t\tpl     = /\\+/g,  // Regex for replacing addition symbol with a space\n\t\t\tsearch = /([^&=]+)=?([^&]*)/g,\n\t\t\tquery  = sSearch,\n\t\t\t_decode = function(s) {\n\t\t\t\treturn decodeURIComponent(s.replace(pl, ' '));\n\t\t\t};\n\t\tlet oURLParams = {};\n\t\twhile (match = search.exec(query)) {\n\t\t\toURLParams[_decode(match[1])] = _decode(match[2]);\n\t\t}\n\t\treturn oURLParams;\n\t}\n\n    static prop(oInstance, sProperty, value) {\n        if (value === undefined) {\n            return oInstance[sProperty];\n        } else {\n            oInstance[sProperty] = value;\n            return oInstance;\n        }\n    }\n};\n\n\nmodule.exports = SpellBook;","/**\n * Created by ralphy on 06/09/17.\n */\n\nconst Helper = require('../../geometry/Helper');\nconst Nood = require('./Nood');\nconst NoodList = require('./NoodList');\nconst Emitter = require('../../Emitter');\nconst Point = require('../../geometry/Point');\nconst SB = require('../../SpellBook');\n\n/**\n * @class\n * this class is an implementation of a-star path finding algorithm\n * how to use :\n * const pf = new Astar()\n * pf.init({\n * \tgrid: [[][]..] give a 2D array of cells here\n * \twalkable: code for walkable cell in the grid\n * \tdiagonals: true if you want to allow diagonal moves\n * \tmax: maximum iteration (act as watch dog)\n * })\n * pf.find(xfrom, yfrom, xto, yto)\n */\nmodule.exports = class Astar {\n\tconstructor() {\n\t\t// configuration\n\t\tthis._bUseDiagonals = false;\n        this._grid = null;\n        this._width = 0;\n        this._height = 0;\n\t\tthis.MAX_ITERATIONS = 4096;\n        this.GRID_BLOCK_WALKABLE = 0;\n\n\t\t// working objects and variables\n        this.oOpList = null;\n        this.oClList = null;\n        this.aPath = null;\n\t\tthis.nIterations = 0;\n\n\t\t// utilities\n\t\tthis.emitter = new Emitter();\n\t}\n\n    on() { this.emitter.on(...arguments); return this; }\n    off() { this.emitter.off(...arguments); return this; }\n    one() { this.emitter.one(...arguments); return this; }\n    trigger() { this.emitter.trigger(...arguments); return this; }\n\n    /**\n\t * modifies a cell value\n     */\n\t_setCell(x, y, n) {\n\t\tif (this._grid[y] !== undefined && this._grid[y][x] !== undefined) {\n\t\t\tthis._grid[y][x] = n;\n\t\t} else {\n\t\t\tthrow new Error(\n\t\t\t\t'Astar: writing tile out of Grid: ' + x + ', ' + y);\n\t\t}\n\t}\n\n\t_getCell(x, y) {\n\t\tif (this._grid[y]) {\n\t\t\tif (x < this._grid[y].length) {\n\t\t\t\treturn this._grid[y][x];\n\t\t\t}\n\t\t}\n\t\tthrow new Error('Astar: read tile out of Grid: ' + x + ', ' + y);\n\t}\n\n\t_isCellWalkable(x, y) {\n\t\ttry {\n\t\t\tlet r = {\n\t\t\t\twalkable: this._getCell(x, y) === this.GRID_BLOCK_WALKABLE,\n\t\t\t\tcell: {\n\t\t\t\t\tx: x,\n\t\t\t\t\ty: y\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis.trigger('walkable', r);\n\t\t\treturn r.walkable;\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t_closeNood(x, y) {\n\t\tlet n = this.oOpList.get(x, y);\n\t\tif (n) {\n\t\t\tthis.oClList.set(x, y, n);\n\t\t\tthis.oOpList.del(x, y);\n\t\t}\n\t}\n\n\t_addAdjacent(x, y, xArrival, yArrival) {\n\t\tlet i, j;\n\t\tlet i0, j0;\n\t\tlet oTmp;\n\t\tlet w = this._width, h = this._height, bDiag = this._bUseDiagonals;\n\t\tfor (i0 = -1; i0 <= 1; i0++) {\n\t\t\ti = x + i0;\n\t\t\tif ((i < 0) || (i >= w)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (j0 = -1; j0 <= 1; j0++) {\n\t\t\t\tif (!bDiag && (j0 * i0) !== 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tj = y + j0;\n\t\t\t\tif ((j < 0) || (j >= h)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ((i === x) && (j === y)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!this._isCellWalkable(i, j)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (!this.oClList.exists(i, j)) {\n\t\t\t\t\toTmp = new Nood();\n\t\t\t\t\toTmp.fGCost = this.oClList.get(x, y).fGCost\t+ Helper.distance(i, j, x, y);\n\t\t\t\t\toTmp.fHCost = Helper.distance(i, j, xArrival, yArrival);\n\t\t\t\t\toTmp.fFCost = oTmp.fGCost + oTmp.fHCost;\n\t\t\t\t\toTmp.oPos = new Point(i, j);\n\t\t\t\t\toTmp.oParent = new Point(x, y);\n\n\t\t\t\t\tif (this.oOpList.exists(i, j)) {\n\t\t\t\t\t\tif (oTmp.fFCost < this.oOpList.get(i, j).fFCost) {\n\t\t\t\t\t\t\tthis.oOpList.set(i, j, oTmp);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.oOpList.set(i, j, oTmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Recherche le meilleur noeud de la liste et le renvoi\n\t_bestNood(oList) {\n\t\tlet oBest = null;\n\t\tlet oNood;\n\n\t\tfor (let iNood in oList.oList) {\n\t\t\toNood = oList.oList[iNood];\n\t\t\tif (oBest === null) {\n\t\t\t\toBest = oNood;\n\t\t\t} else if (oNood.fFCost < oBest.fFCost) {\n\t\t\t\toBest = oNood;\n\t\t\t}\n\t\t}\n\t\treturn oBest;\n\t}\n\n    _buildPath(xTo, yTo) {\n        let oCursor = this.oClList.get(xTo, yTo);\n        if (oCursor !== null) {\n            while (!oCursor.isRoot()) {\n                this.aPath.unshift({\n                    x: oCursor.oPos.x,\n                    y: oCursor.oPos.y\n                });\n                oCursor = this.oClList.get(oCursor.oParent.x, oCursor.oParent.y);\n            }\n        }\n    }\n\n\tfind(xFrom, yFrom, xTo, yTo) {\n\t\tthis.reset();\n\t\tlet oBest;\n\t\tlet oDepart = new Nood();\n\t\toDepart.oPos = new Point(xFrom, yFrom);\n\t\toDepart.oParent = new Point(xFrom, yFrom);\n\t\tlet xCurrent = xFrom;\n\t\tlet yCurrent = yFrom;\n\t\tthis.oOpList.add(oDepart);\n\t\tthis._closeNood(xCurrent, yCurrent);\n\t\tthis._addAdjacent(xCurrent, yCurrent, xTo, yTo);\n\n\t\tlet iIter = 0, MAX = this.MAX_ITERATIONS;\n\n\t\twhile (!((xCurrent === xTo) && (yCurrent === yTo)) && (!this.oOpList.empty())) {\n\t\t\toBest = this._bestNood(this.oOpList);\n\t\t\tif (!oBest) {\n\t\t\t\t// could not find path\n                throw new Error('Astar: no path to destination');\n\t\t\t}\n\t\t\txCurrent = oBest.oPos.x;\n\t\t\tyCurrent = oBest.oPos.y;\n\t\t\tthis._closeNood(xCurrent, yCurrent);\n\t\t\tthis._addAdjacent(oBest.oPos.x, oBest.oPos.y, xTo, yTo);\n\t\t\tif (++iIter > MAX) {\n\t\t\t\tthrow new Error('Astar: too much iterations');\n\t\t\t}\n\t\t}\n\t\tif (this.oOpList.empty() && !((xCurrent === xTo) && (yCurrent === yTo))) {\n\t\t\tthrow new Error('Astar: no path to destination');\n\t\t}\n\t\tthis.nIterations = iIter;\n\t\tthis._buildPath(xTo, yTo);\n\t\treturn this.aPath;\n\t}\n\n    /**\n\t * Changes a cell value inside the grid\n     * @param x {number} cell coordinates\n     * @param y {number} cell coordinates\n     * @param (v) {number} new value\n     * @return {*}\n     */\n\tcell(x, y, v) {\n        if (v === undefined) {\n            return this._getCell(x, y);\n        } else {\n            this._setCell(x, y, v);\n            return this;\n        }\n    }\n\n    /**\n     * resets the grid\n     * @return {*}\n     */\n    reset() {\n        this.oOpList = new NoodList();\n        this.oClList = new NoodList();\n        this.aPath = [];\n        this.nIterations = 0;\n        return this;\n    }\n\n    /**\n     * Setter/Getter of the internal grid.\n     * @param (g) {[]}\n     * @return {[]|Astar}\n     */\n    grid(g) {\n        if (g !== undefined) {\n            this._height = g.length;\n            this._width = g[0].length;\n        }\n        return SB.prop(this, '_grid', g);\n    }\n\n\t/**\n\t * Setter/getter of the walkable code.\n\t * This code is use to determine if a grid cell is walkable or not.\n\t * @param (w) {string|number}\n\t * @return {string|number|Astar}\n\t */\n\twalkable(w) {\n\t\treturn SB.prop(this, 'GRID_BLOCK_WALKABLE', w);\n\t}\n\n\t/**\n\t * Setter/getter of the diagonal flag.\n\t * if set to true, the path finder will cross the grid diagonaly if needed.\n\t * @param (b) {boolean}\n\t * @return {boolean|Astar}\n\t */\n\tdiagonals(b) {\n\t\treturn SB.prop(this, '_bUseDiagonals', b);\n\t}\n};\n","/**\n * Created by ralphy on 04/09/17.\n */\n\nconst Point = require('../../geometry/Point.js');\n\nmodule.exports = class Nood {\n\tconstructor() {\n\t\tthis.fGCost = 0.0;\n\t\tthis.fHCost = 0.0;\n\t\tthis.fFCost = 0.0;\n\t\tthis.oParent = new Point(0, 0);\n\t\tthis.oPos = new Point(0, 0);\n\t}\n\n\tisRoot() {\n\t\treturn this.oParent.x === this.oPos.x && this.oParent.y === this.oPos.y;\n\t}\n};\n","/**\n * Created by ralphy on 06/09/17.\n */\n\n/**\n * The NoodList class is a simple class aimed at facilitating nood list manipulations\n */\nmodule.exports = class NoodList {\n\tconstructor() {\n\t\tthis.oList = {};\n\t}\n\n\t/**\n\t * adds an instance of Nood in the list\n\t * @param oNood\n\t */\n\tadd(oNood) {\n\t\tthis.set(oNood.oPos.x, oNood.oPos.y, oNood);\n\t}\n\n\t/**\n\t * Sets an instance of Nood in the list\n\t * a Nood is indexed by its position. Thus two Nood shall not have the same x and y pair\n\t * @param x {number}\n\t * @param y {number}\n\t * @param oNood {Nood}\n\t */\n\tset(x, y, oNood) {\n\t\tthis.oList[this.getKey(x, y)] = oNood;\n\t}\n\n\t/**\n\t * Returns the numbers of Nood in the list\n\t * @return {number}\n\t */\n\tcount() {\n\t\treturn Object(this.oList).length;\n\t}\n\n\t/**\n\t * Returns true if the spécified position (x, y) has a matching Nood in the list\n\t * @param x {number}\n\t * @param y {number}\n\t * @returns {boolean}\n\t */\n\texists(x, y) {\n\t\treturn this.getKey(x, y) in this.oList;\n\t}\n\n\t/**\n\t * Creates a key from an x and y values\n\t * @param x {number}\n\t * @param y {number}\n\t * @returns {string}\n\t */\n\tgetKey(x, y) {\n\t\treturn x.toString() + '__' + y.toString();\n\t}\n\n\t/**\n\t * Gets the Nood matching the given x y pair\n\t * Returns null if does not exists\n\t * @param x {number}\n\t * @param y {number}\n\t * @returns {Nood|null}\n\t */\n\tget(x, y) {\n\t\treturn this.oList[this.getKey(x, y)] || null;\n\t}\n\n\t/**\n\t * Remove a Nood from the list with the given coordinates\n\t * @param x {number}\n\t * @param y {number}\n\t */\n\tdel(x, y) {\n\t\tdelete this.oList[this.getKey(x, y)];\n\t}\n\n\t/**\n\t * Returns true if the liste is empty\n\t * @returns {boolean}\n\t */\n\tempty() {\n\t\treturn this.count() === 0;\n\t}\n};","const Astar = require('./Astar');\n\nmodule.exports = Astar;\n","/**\n * This class implements the bresenham algorithm\n * and extend its use for other purpose than drawing pixel lines\n * good to GIT\n */\nmodule.exports = class Bresenham {\n\t/**\n\t * This function will virtually draw points along a line\n\t * and will call back a plot function. \n\t * The line will start at x0, y0 and will end at x1, y1\n\t * Each time a points is \"drawn\" a callback is done \n\t * if the callback returns false, the line function will stop and return false\n\t * else the line function will return an array of plots\n\t * @param x0 starting point x\n\t * @param y0 starting point y\n\t * @param x1 ending point x\n\t * @param y1 ending point y\n\t * @param pCallback a plot function of type function(x, y, n) { return bool; }\n\t * avec x, y les coordonnées du point et n le numéro duj point\n\t * @returns {Boolean} false if the fonction has been canceled\n\t */\n\tstatic line(x0, y0, x1, y1, pCallback) {\n\t\tx0 |= 0;\n\t\ty0 |= 0;\n\t\tx1 |= 0;\n\t\ty1 |= 0;\n\t\tlet dx = Math.abs(x1 - x0);\n\t\tlet dy = Math.abs(y1 - y0);\n\t\tlet sx = (x0 < x1) ? 1 : -1;\n\t\tlet sy = (y0 < y1) ? 1 : -1;\n\t\tlet err = dx - dy;\n\t\tlet e2;\n\t\tlet n = 0;\n\t\twhile (true) {\n\t\t\tif (pCallback) {\n\t\t\t\tif (pCallback(x0, y0, n) === false) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x0 === x1 && y0 === y1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\te2 = err << 1;\n\t\t\tif (e2 > -dy) {\n\t\t\t\terr -= dy;\n\t\t\t\tx0 += sx;\n\t\t\t}\n\t\t\tif (e2 < dx) {\n\t\t\t\terr += dx;\n\t\t\t\ty0 += sy;\n\t\t\t}\n\t\t\t++n;\n\t\t}\n\t\treturn true;\n\t}\n};\n","/** Interface de controle des mobile \n * O876 Raycaster project\n * @class O876.Easing\n * @date 2013-03-04\n * @author Raphaël Marandet \n * Fait bouger un mobile de manière non-lineaire\n * Avec des coordonnée de dépat, d'arriver, et un temps donné\n * L'option lineaire est tout de même proposée.\n * good to GIT\n */\nmodule.exports = class Easing {\n\n\tconstructor() {\n\t\tthis.xStart = 0;\n\t\tthis.xEnd = 0;\n\t\tthis.x = 0;\n\t\tthis.nTime = 0;\n\t\tthis.iTime = 0;\n\t\tthis.fWeight = 1;\n\t\tthis.pFunction = null;\n\t}\n\n    /**\n\t * Will define de starting value\n     * @param x {number}\n     * @returns {O876.Easing}\n     */\n\tfrom(x) {\n\t\tthis.xStart = this.x = x;\n\t\treturn this;\n\t}\n\n    /**\n\t * Will define the ending value\n     * @param x {number}\n     * @returns {O876.Easing}\n     */\n\tto(x) {\n\t\tthis.xEnd = x;\n\t\treturn this;\n\t}\n\n    /**\n\t * Will define the duration of the transition\n     * @param t {number} arbitrary unit\n     * @returns {O876.Easing}\n     */\n\tduring(t) {\n\t\tthis.nTime = t;\n\t\tthis.iTime = 0;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Définition de la fonction d'Easing\n\t * @param xFunction {string|Function} fonction à choisir parmi :\n\t * linear : mouvement lineaire uniforme\n\t * smoothstep : accelération et déccelération douce\n\t * smoothstepX2 : accelération et déccelération moyenne\n\t * smoothstepX3 : accelération et déccelération brutale\n\t * squareAccel : vitesse 0 à T-0 puis uniquement accelération \n\t * squareDeccel : vitesse max à T-0 puis uniquement deccelération\n\t * cubeAccel : vitesse 0 à T-0 puis uniquement accelération brutale \n\t * cubeDeccel : vitesse max à T-0 puis uniquement deccelération brutale\n\t * sine : accelération et deccelération brutal, vitesse nulle à mi chemin\n\t * cosine : accelération et deccelération selon le cosinus, vitesse max à mi chemin\n\t * weightAverage : ... me rapelle plus \n\t */\n\tuse(xFunction) {\n\t\tswitch (typeof xFunction) {\n\t\t\tcase 'string':\n\t\t\t\tthis.pFunction = this['_' + xFunction].bind(this);\n\t\t\tbreak;\n\n\t\t\tcase 'function':\n\t\t\t\tthis.pFunction = xFunction;\n\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error('unknown function type');\n\t\t}\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Calcule les coordonnée pour le temps t\n\t * mets à jour les coordonnée x et y de l'objets\n\t * @param t {number} temps\n\t * si \"t\" est indéfini, utilise le timer interne \n\t */\n\tnext(t) {\n\t\tif (t === undefined) {\n\t\t\tt = ++this.iTime;\n\t\t} else {\n\t\t\tthis.iTime = t;\n\t\t}\n\t\tlet p = this.pFunction;\n\t\tif (typeof p !== 'function') {\n\t\t\tthrow new Error('easing function is invalid : ' + p);\n\t\t}\n\t\tlet v = p(t / this.nTime);\n\t\tthis.x = this.xEnd * v + (this.xStart * (1 - v));\n\t\treturn this;\n\t}\n\n\tval() {\n\t\treturn this.x;\n\t}\n\n\tover() {\n\t\treturn this.iTime >= this.nTime;\n\t}\n\n\t_linear(v) {\n\t\treturn v;\n\t}\n\t\n\t_smoothstep(v) {\n\t\treturn v * v * (3 - 2 * v);\n\t}\n\t\n\t_smoothstepX2(v) {\n\t\tv = v * v * (3 - 2 * v);\n\t\treturn v * v * (3 - 2 * v);\n\t}\n\t\n\t_smoothstepX3(v) {\n\t\tv = v * v * (3 - 2 * v);\n\t\tv = v * v * (3 - 2 * v);\n\t\treturn v * v * (3 - 2 * v);\n\t}\n\t\n\t_squareAccel(v) {\n\t\treturn v * v;\n\t}\n\t\n\t_squareDeccel(v) {\n\t\treturn 1 - (1 - v) * (1 - v);\n\t}\n\t\n\t_cubeAccel(v) {\n\t\treturn v * v * v;\n\t}\n\t\n\t_cubeDeccel(v) {\n\t\treturn 1 - (1 - v) * (1 - v) * (1 - v);\n\t}\n\t\n\t_cubeInOut(v) {\n\t\tif (v < 0.5) {\n\t\t\tv = 2 * v;\n\t\t\treturn v * v * v;\n\t\t} else {\n\t\t\tv = (1 - v) * 2;\n\t\t\treturn v * v * v;\n\t\t}\n\t}\n\t\n\t_sine(v) {\n\t\treturn Math.sin(v * Math.PI / 2);\n\t}\n\t\n\t_cosine(v) {\n\t\treturn 0.5 - Math.cos(-v * Math.PI) * 0.5;\n\t}\n\t\n\t_weightAverage(v) {\n\t\treturn ((v * (this.nTime - 1)) + this.fWeight) / this.nTime;\n\t}\n\t\n\t_quinticBezier(v) {\n\t\tlet ts = v * this.nTime;\n\t\tlet tc = ts * this.nTime;\n\t\treturn 4 * tc - 9 * ts + 6 * v;\n\t}\n};","const SpellBook = require('../SpellBook');\nconst Random = require('../Random');\nconst Rainbow = require('../Rainbow');\n\n\nclass Perlin {\n\n\tconstructor() {\n\t\tthis._size = 64;\n\t\tthis._width = 64;\n\t\tthis._height = 64;\n\t\tthis._octaves = 8;\n\t\tthis._interpolate = null;\n\t\tthis._rand = new Random();\n\t\tthis.interpolation('cosine');\n\t\tthis._cache = [];\n\t\tthis._seed = 1;\n\t}\n\n\tseed(n) {\n\t\treturn SpellBook.prop(this, '_seed', n);\n\t}\n\t\n\tsize(n) {\n\t\tif (n === undefined) {\n\t\t\treturn this._size;\n\t\t} else {\n\t\t\tlet i = 10;\n\t\t\twhile (i > 0) {\n\t\t\t\tlet i2 = 1 << i;\n\t\t\t\tif (i2 === n) {\n\t\t\t\t\tthis._width = i2;\n\t\t\t\t\tthis._height = i2;\n\t\t\t\t\tthis._octaves = i;\n\t\t\t\t\tthis._size = n;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\t--i;\n\t\t\t}\n\t\t\tthrow new Error('size must be a power of 2 between 2 and 1024');\n\t\t}\n\t}\n\t\n\twidth() {\n\t\treturn this._width;\n\t}\n\n\theight(h) {\n\t\treturn this._height;\n\t}\n\t\n\toctaves(n) {\n\t\treturn this._octaves;\n\t}\n\n\t/**\n\t * Generate white noise on a matrix\n\t * @param w matrix width\n\t * @param h matrix height\n\t * @return {array}\n\t */\n\tgenerateWhiteNoise(w, h) {\n\t\tlet r, a = [];\n\t\tfor (let x, y = 0; y < h; ++y) {\n\t\t\tr = []; \n\t\t\tfor (x = 0; x < w; ++x) {\n\t\t\t\tr.push(this._rand.rand());\n\t\t\t}\n\t\t\ta.push(r);\n\t\t}\n\t\treturn a;\n\t}\n\n\t/**\n\t * Linear interpolation\n\t * @param x0 minimum\n\t * @param x1 maximum\n\t * @param alpha value between 0 and 1\n\t * @return float, interpolation result\n\t */\n\tlinearInterpolate(x0, x1, alpha) {\n\t\treturn x0 * (1 - alpha) + alpha * x1;\n\t}\n\n\t/**\n\t * Cosine Interpolation\n\t */\n\tcosineInterpolate(x0, x1, mu) {\n\t\tlet mu2 = (1 - Math.cos(mu * Math.PI)) / 2;\n   \t\treturn x0 * (1 - mu2) + x1 * mu2;\n\t}\n\n\t/**\n\t * selects or define an interpolation function\n\t * @param f string | function the new interpolation function\n\t * f can be either a string ('cosine', 'linear') or a custom function\n\t */\n\tinterpolation(f) {\n\t\tswitch (typeof f) {\n\t\t\tcase 'string':\n\t\t\t\tif ((f + 'Interpolate') in this) {\n\t\t\t\t\tthis._interpolate = this[f + 'Interpolate'];\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error('only \"linear\" or \"cosine\" interpolation');\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t\t\n\t\t\tcase 'function':\n\t\t\t\tthis._interpolate = f;\n\t\t\t\treturn this;\n\t\t\t\t\n\t\t\tcase 'undefined':\n\t\t\t\treturn this._interpolate;\n\t\t}\n\t\treturn this;\n\t}\n\n\tgenerateSmoothNoise(aBaseNoise, nOctave) {\n\t\tlet w = aBaseNoise.length;\n\t\tlet h = aBaseNoise[0].length;\n\t\tlet aSmoothNoise = [];\n\t\tlet r;\n\t\tlet nSamplePeriod = 1 << nOctave;\n\t\tlet fSampleFreq = 1 / nSamplePeriod;\n\t\tlet xs = [], ys = [];\n\t\tlet hBlend, vBlend, fTop, fBottom;\n\t\tfor (let x, y = 0; y < h; ++y) {\n      \t\tys[0] = (y / nSamplePeriod | 0) * nSamplePeriod;\n      \t\tys[1] = (ys[0] + nSamplePeriod) % h;\n      \t\thBlend = (y - ys[0]) * fSampleFreq;\n      \t\tr = [];\n      \t\tfor (x = 0; x < w; ++ x) {\n       \t\t\txs[0] = (x / nSamplePeriod | 0) * nSamplePeriod;\n      \t\t\txs[1] = (xs[0] + nSamplePeriod) % w;\n      \t\t\tvBlend = (x - xs[0]) * fSampleFreq;\n\n      \t\t\tfTop = this._interpolate(aBaseNoise[ys[0]][xs[0]], aBaseNoise[ys[1]][xs[0]], hBlend);\n      \t\t\tfBottom = this._interpolate(aBaseNoise[ys[0]][xs[1]], aBaseNoise[ys[1]][xs[1]], hBlend);\n     \t\t\t\n     \t\t\tr.push(this._interpolate(fTop, fBottom, vBlend));\n      \t\t}\n\n      \t\taSmoothNoise.push(r);\n\t\t}\n\t\treturn aSmoothNoise;\n\t}\n\n\tgeneratePerlinNoise(aBaseNoise, nOctaveCount) {\n\t\tlet w = aBaseNoise.length;\n\t\tlet h = aBaseNoise[0].length;\n\t\tlet aSmoothNoise = [];\n\t\tlet fPersist = 0.5;\n\n\t\tfor (let i = 0; i < nOctaveCount; ++i) {\n\t\t\taSmoothNoise.push(this.generateSmoothNoise(aBaseNoise, i));\n\t\t}\n\n\t\tlet aPerlinNoise = [];\n\t\tlet fAmplitude = 1;\n\t\tlet fTotalAmp = 0;\n\t\tlet x, y, r;\n\n\t\tfor (y = 0; y < h; ++y) {\n\t\t\tr = [];\n\t\t\tfor (x = 0; x < w; ++x) {\n\t\t\t\tr.push(0);\n\t\t\t}\n\t\t\taPerlinNoise.push(r);\n\t\t}\n\n\t\tfor (let iOctave = nOctaveCount - 1; iOctave >= 0; --iOctave) {\n\t\t\tfAmplitude *= fPersist;\n\t\t\tfTotalAmp += fAmplitude;\n\n\t\t\tfor (y = 0; y < h; ++y) {\n\t\t\t\tr = [];\n\t\t\t\tfor (x = 0; x < w; ++x) {\n\t\t\t\t\taPerlinNoise[y][x] += aSmoothNoise[iOctave][y][x] * fAmplitude;\n\t\t\t\t}\n\t\t\t} \n\t\t}\n\t\tfor (y = 0; y < h; ++y) {\n\t\t\tr = [];\n\t\t\tfor (x = 0; x < w; ++x) {\n\t\t\t\taPerlinNoise[y][x] /= fTotalAmp;\n\t\t\t}\n\t\t}\n\t\treturn aPerlinNoise;\n\t}\n\n\n\tstatic hash (a) {\n\t\tif (a < 0) {\n\t\t\tlet b = 0, h = Perlin.hash(-a);\n\t\t\twhile (h) {\n\t\t\t\tb = (b << 4) | h & 15;\n\t\t\t\th >>= 4;\n\t\t\t}\n\t\t\treturn Math.abs(b);\n\t\t}\n\t    a = (a ^ 61) ^ (a >> 16);\n\t    a = a + (a << 3);\n\t    a = a ^ (a >> 4);\n\t    a = a * 0x27d4eb2d;\n\t    a = a ^ (a >> 15);\n    \treturn a;\n    }\n\n\t/** \n\t * Calcule le hash d'une région\n\t * Permet de choisir une graine aléatoire\n\t * et de raccorder seamlessly les région adjacente\n\t */\n\tstatic getPointHash(x, y) {\n\t\tlet xh = Perlin.hash(x).toString().split('');\n\t\tlet yh = Perlin.hash(y).toString().split('');\n\t\tlet s = xh.shift() + yh.shift() + '.';\n\t\tif (s === '--.') {\n\t\t//\ts = '0.';\n\t\t}\n\t\twhile (xh.length || yh.length) {\n\t\t\tif (xh.length) {\n\t\t\t\ts += xh.shift();\n\t\t\t}\n\t\t\tif (yh.length) {\n\t\t\t\ts += yh.shift();\n\t\t\t}\n\t\t}\n\t\treturn parseFloat(s);\n\t}\n\t\n\tgetCache(x, y) {\n\t\tif (this._cache.length) {\n\t\t\tlet k = Perlin.getPointHash(x, y);\n\t\t\tlet c = this._cache.find(cc => cc.key === k);\n\t\t\tif (c) {\n\t\t\t\treturn c.data;\n\t\t\t}\n\t\t}\n\t\treturn null;\t\n\t}\n\t\n\tpushCache(x, y, data) {\n\t\tthis._cache.push({\n\t\t\tkey: Perlin.getPointHash(x, y),\n\t\t\tdata: data\n\t\t});\n\t\twhile (this._cache.length > 16) {\n\t\t\tthis._cache.shift();\n\t\t}\n\t}\n\t\n\tgenerate(x, y, callbacks) {\n\t\tif (x >= Number.MAX_SAFE_INTEGER || x <= -Number.MAX_SAFE_INTEGER || y >= Number.MAX_SAFE_INTEGER || y <= -Number.MAX_SAFE_INTEGER) {\n\t\t\tthrow new Error('trying to generate x:' + x + ' - y:' + y + ' - maximum safe integer is ' + Number.MAX_SAFE_INTEGER + ' !');\n\t\t}\n\t\tcallbacks = callbacks || {};\n\t\tlet perlin = 'perlin' in callbacks ? callbacks.perlin : null;\n\t\tlet noise = 'noise' in callbacks ? callbacks.noise : null;\n\t\tlet cached = this.getCache(x, y);\n\t\tif (cached) {\n\t\t\treturn cached;\n\t\t}\n\t\t\n\t\tconst gwn = (xg, yg) => {\n\t\t\tlet nSeed = Perlin.getPointHash(xg, yg);\n\t\t\tthis._rand.seed(nSeed + this._seed);\n\t\t\tlet aNoise = this.generateWhiteNoise(this.width(), this.height());\n\t\t\tif (noise) {\n\t\t\t\taNoise = noise(xg, yg, aNoise);\n\t\t\t}\n\t\t\treturn aNoise;\n\t\t};\n\n\t\tconst merge33 = a33 => {\n\t\t\tlet h = this.height();\n\t\t\tlet a = [];\n\t\t\tfor (let y, ya = 0; ya < 3; ++ya) {\n\t\t\t\tfor (y = 0; y < h; ++y) {\n\t\t\t\t\ta.push(a33[ya][0][y].concat(a33[ya][1][y], a33[ya][2][y]));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn a;\n\t\t};\n\n\t\tconst extract33 = a => {\n\t\t\tlet w = this.width();\n\t\t\tlet h = this.height();\n\t\t\treturn a.slice(h, h * 2).map(function(r) { return r.slice(w, w * 2); });\n\t\t};\n\n\t\tlet a0 = [\n\t\t\t[gwn(x - 1, y - 1), gwn(x, y - 1), gwn(x + 1, y - 1)],\n\t\t\t[gwn(x - 1, y), gwn(x, y), gwn(x + 1, y)],\n\t\t\t[gwn(x - 1, y + 1), gwn(x, y + 1), gwn(x + 1, y + 1)]\n\t\t];\n\n\t\tlet a1 = merge33(a0);\n\t\tlet a2 = this.generatePerlinNoise(a1, this._octaves);\n\t\tlet a3 = extract33(a2);\n\t\tif (perlin) {\n\t\t\ta3 = perlin(x, y, a3);\n\t\t}\n\t\tthis.pushCache(x, y, a3);\n\t\treturn a3;\n\t}\n\n\t/**\n\t * @param aNoise {Array} an array produced by generate()\n\t * @param oContext {CanvasRenderingContext2D}\n\t */\n\trender(aNoise, oContext, aPalette) {\n\t\taPalette = aPalette || Rainbow.gradient({\n\t\t\t0: '#008',\n\t\t\t44: '#00F',\n\t\t\t49: '#44F',\n\t\t\t50: '#864',\n\t\t\t74: '#080',\n\t\t\t75: '#555',\n\t\t\t89: '#777',\n\t\t\t90: '#AAA',\n\t\t\t99: '#FFF'\n\t\t});\n\t\tlet h = aNoise.length, w = aNoise[0].length, pl = aPalette.length;\n\t\tlet oImageData = oContext.createImageData(w, h);\n\t\tlet data = oImageData.data;\n\t\taNoise.forEach(function(r, y) {\n\t\t\tr.forEach(function(p, x) {\n\t\t\t\tlet nOfs = (y * w + x) << 2;\n\t\t\t\tlet rgb = Rainbow.parse(aPalette[Math.min(aPalette.length - 1, p * pl | 0)]);\n\t\t\t\tif (rgb === undefined) {\n\t\t\t\t\tthrow new Error('entry \"' + (p * pl | 0) + '\" is not in palette');\n\t\t\t\t}\n\t\t\t\tdata[nOfs] = rgb.r;\n\t\t\t\tdata[nOfs + 1] = rgb.g;\n\t\t\t\tdata[nOfs + 2] = rgb.b;\n\t\t\t\tdata[nOfs + 3] = 255;\n\t\t\t});\n\t\t});\n\t\toContext.putImageData(oImageData, 0, 0);\n\t}\n};\n\nmodule.exports = Perlin;","/**\n * @class SquareSpiral\n * This simple class builds a squared shape spiral\n * and reports all cells into an ordered list of Point\n * starting from the spiral center.\n */\n\nmodule.exports = class SquareSpiral {\n\t/**\n\t * Renvoie la largeur d'un carré de snail selon le niveau\n\t * @param nLevel niveau\n\t * @return int nombre d'élément sur le coté\n\t */\n\tstatic _getLevelSquareWidth(nLevel) {\n\t\treturn nLevel * 2 + 1;\n\t}\n\t\n\t/**\n\t * Renvoie le nombre d'éléments qu'il y a dans un niveau\n\t * @param nLevel niveau\n\t * @return int nombre d'élément\n\t */\n\tstatic _getLevelItemCount(nLevel) {\n\t\tlet w = SquareSpiral._getLevelSquareWidth(nLevel);\n\t\treturn 4 * w - 4;\n\t}\n\t\n\t/**\n\t * Renvoie le niveau auquel appartient ce secteur\n\t * le niveau 0 correspond au point 0, 0\n\t */\n\tstatic _getLevel(x, y) {\n\t\tx = Math.abs(x);\n\t\ty = Math.abs(y);\n\t\treturn Math.max(x, y);\n\t}\n\t\n\t/**\n\t * Renvoie tous les secteurs de niveau spécifié\n\t */\n\tstatic build(nLevelMin, nLevelMax) {\n\t\tif (nLevelMax === undefined) {\n\t\t\tnLevelMax = nLevelMin;\n\t\t}\n\t\tif (nLevelMin > nLevelMax) {\n\t\t\tthrow new Error('levelMin must be lower or equal levelMax');\n\t\t}\n\t\tif (nLevelMin < 0) {\n\t\t\treturn [];\n\t\t}\n\t\tlet aSectors = [];\n\t\tlet n, x, y;\n\t\tfor (y = -nLevelMax; y <= nLevelMax; ++y) {\n\t\t\tfor (x = -nLevelMax; x <= nLevelMax; ++x) {\n\t\t\t\tn = SquareSpiral._getLevel(x, y);\n\t\t\t\tif (n >= nLevelMin && n <= nLevelMax) {\n\t\t\t\t\taSectors.push({x: x, y: y});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn aSectors;\n\t}\n};\n","const Bresenham = require('./Bresenham');\nconst Easing = require('./Easing');\nconst Perlin = require('./Perlin');\nconst SquareSpiral = require('./SquareSpiral');\nconst Astar = require('./Astar');\n\nmodule.exports = {\n    Bresenham,\n    Easing,\n    Perlin,\n    SquareSpiral,\n    Astar\n};\n","/**\n * @class Collider\n * The collider computes collision between sprites.\n * Sprites are positionned inside the collider grid, according to their position\n * Each sprites is tested against all other sprite in the surroundiing cells.\n */\n\nconst Vector = require('../geometry/Vector');\nconst Grid = require('../structures/Grid');\nconst Sector = require('./Sector');\nconst SB = require('../SpellBook');\n\nmodule.exports = class Collider {\n\tconstructor() {\n        this._origin = new Vector(); // vector origine du layer\n        this._grid = new Grid();\n        this._grid.on('rebuild', function(data) {\n            let oSector = new Sector();\n            oSector.x = data.x;\n            oSector.y = data.y;\n            data.cell = oSector;\n        });\n        this._cellWidth = 0;\n        this._cellHeight = 0;\n\t}\n\n    cellWidth(w) {\n        return SB.prop(this, '_cellWidth', w);\n    }\n\n    cellHeight(h) {\n        return SB.prop(this, '_cellHeight', h);\n    }\n\n    width(w) {\n        if (w === undefined) {\n            return this._grid.width();\n        } else {\n            this._grid.width(w);\n            return this;\n        }\n    }\n\n    height(h) {\n        if (h === undefined) {\n            return this._grid.height();\n        } else {\n            this._grid.height(h);\n            return this;\n        }\n    }\n\n\t/**\n\t * Return the sector corresponding to the given coordinates\n     * if the parameters are number, the real sector indices are used (0, 1, 2...)\n\t * if the parameter is a Vector, its components are int-divided by cell size before application\n\t * @param x {number} position x\n\t * @param y {number} position y\n\t * @return {*}\n\t */\n\tsector(x, y) {\n\t\tif (y === undefined) {\n\t\t\treturn this._grid.cell(x.x / this._cellWidth | 0, x.y / this._cellHeight | 0);\n\t\t} else {\n\t\t\treturn this._grid.cell(x, y);\n\t\t}\n\t}\n\n\t/**\n\t * Registers an object in the sector it belongs\n\t * Unregisters the objet in all other sector\n\t * @param oDummy {Dummy}\n\t */\n\ttrack(oDummy) {\n\t\tlet oOldSector = oDummy.colliderSector;\n\t\tlet v = oDummy.position().sub(this._origin);\n\t\tlet s = oDummy.dead() ? null : this.sector(v);\n\t\tif (s && oOldSector && s === oOldSector) {\n\t\t\treturn;\n\t\t}\n\t\tif (oOldSector) {\n\t\t\toOldSector.remove(oDummy);\n\t\t}\n\t\tif (s) {\n\t\t\ts.add(oDummy);\n\t\t}\n\t\toDummy.colliderSector = s;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Effectue tous les test de collision entre un objet et tous les autres objets\n\t * contenus dans les secteur adjacent a celui de l'objet\n\t * @param oDummy {Dummy}\n\t * @return {Dummy[]} liste d'objet collisionnant\n\t */\n\tcollides(oDummy) {\n\t\tlet a = [];\n\t\tlet oSector = this.sector(oDummy.position().sub(this._origin));\n\t\tif (!oSector) {\n\t\t\treturn a;\n\t\t}\n\t\tlet x = oSector.x;\n\t\tlet y = oSector.y;\n\t\tlet xMin = Math.max(0, x - 1);\n\t\tlet yMin = Math.max(0, y - 1);\n\t\tlet xMax = Math.min(this.width() - 1, x + 1);\n\t\tlet yMax = Math.min(this.height() - 1, y + 1);\n\t\tlet ix, iy;\n\t\tfor (iy = yMin; iy <= yMax; ++iy) {\n\t\t\tfor (ix = xMin; ix <= xMax; ++ix) {\n\t\t\t\ta = a.concat(this.sector(ix, iy).collides(oDummy));\n\t\t\t}\n\t\t}\n\t\treturn a;\n\t}\n};","/**\n * @class Mobile\n * This class manages a mobile object.\n */\nconst sb = require('../SpellBook');\nconst geometry = require('../geometry');\nconst Helper = geometry.Helper;\nconst Vector = geometry.Vector;\n\nmodule.exports = class Dummy {\n\tconstructor() {\n\t\tthis._position = new Vector();\n\t\tthis._dead = false; // les mobile noté \"dead\" doivent être retiré du jeu\n\t\tthis._radius = 0;\n\t\tthis._tangibility = {\n\t\t\tself: 1,\n\t\t\thitmask: 1\n\t\t};\n\t}\n\n\t/**\n\t * Renvoie true si le masque-tangibilité de ce dummy correspond au type-tangibilité du dummy spécifié\n\t * @param dummy\n\t */\n\ttangibleWith(dummy) {\n\t\treturn (dummy._tangibility.self & this._tangibility.hitmask) !== 0;\n\t}\n\n    /**\n\t * Setter/getter du rayon du mobile\n     * @param r\n     * @returns {*}\n     */\n\tradius(r) {\n        return sb.prop(this, '_radius', r);\n\t}\n\n    /**\n\t * Setter/Getter de la position du mobile\n     * @param p\n     * @returns {*}\n     */\n\tposition(p) {\n        return sb.prop(this, '_position', p);\n\t}\n\n    /**\n     * Setter/Getter of dead flag...\n     * dead Mobile must be removed from game\n     * @param b {boolean}\n     * @return {boolean|Mobile}\n     */\n    dead(b) {\n        return sb.prop(this, '_dead', b);\n    }\n\n    /**\n\t * Calcule la distance entre le mobile et un autre mobile\n     * @param oOther {Mobile}\n     * @returns {*|float|number}\n     */\n\tdistanceTo(oOther) {\n\t\tlet p1 = this.position();\n\t\tlet p2 = oOther.position();\n        return Helper.distance(p1.x, p1.y, p2.x, p2.y);\n\t}\n\n    /**\n\t * Renvoi l'angle entre les deux mobile (this et oOther) et l'axe X\n     * @param oOther\n     * @returns {number}\n     */\n\tangleTo(oOther) {\n        let p1 = this.position();\n        let p2 = oOther.position();\n        return Helper.angle(p1.x, p1.y, p2.x, p2.y);\n\t}\n\n    /**\n\t * renvoie true si les deux mobile se collisionne.\n     * @param oOther {Dummy}\n     * @returns {boolean}\n     */\n\thits(oOther) {\n\t\treturn this.tangibleWith(oOther) && this.distanceTo(oOther) < this._radius + oOther.radius();\n\t}\n};","/**\n * Classe enregistrant les mobile qui s'aventure dans un secteur particulier\n * du monde. LEs Mobile d'un même secteurs sont testé entre eux pour savoir\n * Qui entre en collision avec qui. */\nmodule.exports = class Sector {\n    constructor() {\n        this._objects = [];\n        this.x = -1;\n        this.y = -1;\n    }\n\n    objects() {\n        return this._objects;\n    }\n\n    add(oObject) {\n        this._objects.push(oObject);\n    }\n\n    remove(oObject) {\n        let objects = this._objects;\n        let n = objects.indexOf(oObject);\n        if (n >= 0) {\n            objects.splice(n, 1);\n        }\n    }\n\n    /**\n     * Renvoie le nombre d'objet enregistrer dans le secteur\n     * @return int\n     */\n    count() {\n        return this._objects.length;\n    }\n\n    /** Renvoie l'objet désigné par son rang */\n    get(i) {\n        return this._objects[i] || null;\n    }\n\n    /** Renvoie les objets qui collisione avec l'objet spécifié */\n    collides(oObject) {\n        return this._objects\n            .filter(function(o) {\n                return o !== oObject &&\n                    oObject.hits(o)\n            });\n    }\n};\n\n\n","const Dummy = require('./Dummy');\nconst Collider = require('./Collider');\nconst Sector = require('./Sector');\n\nmodule.exports = {\n    Dummy,\n    Collider,\n    Sector\n};","/**\n * Created by ralphy on 07/09/17.\n */\n\n/**\n * A simple helper class\n */\nmodule.exports = class Helper {\n\t/**\n\t * Distance between 2 points\n\t * @param x1 {Number} point 1 coordinates\n\t * @param y1 {Number}\n\t * @param x2 {Number} point 2 coordinates\n\t * @param y2 {Number}\n\t * @return {number} distance\n\t */\n\tstatic distance(x1, y1, x2, y2) {\n\t\tlet dx = x1 - x2;\n\t\tlet dy = y1 - y2;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t}\n\n    /**\n\t * Renvoie l'ange que fait la doite x1, y1, x2, y2\n\t * avec l'axe des X+\n     * @param x1 {number}\n     * @param y1 {number}\n     * @param x2 {number}\n     * @param y2 {number}\n\t * @return {number}\n     */\n\tstatic angle(x1, y1, x2, y2) {\n\t\treturn Math.atan2(y2 - y1, x2 - x1);\n\t}\n\n\t/**\n\t * A partir d'un angle et d'une norme, calcule deux composant d'un référentiel rectangulaire\n\t * @param angle\n\t * @param norm\n\t */\n\tstatic polar2rect(angle, norm) {\n\t\treturn {dx: norm * Math.cos(angle), dy: norm * Math.sin(angle)};\n\t}\n};","/**\n * Created by ralphy on 04/09/17.\n */\n\nconst Helper = require('./Helper');\n\nmodule.exports = class Point {\n\tconstructor(x, y) {\n\t\tif (typeof x === 'object' && ('x' in x) && ('y' in x)) {\n\t\t\tthis.x = x.x;\n\t\t\tthis.y = x.y;\n\t\t} else {\n            this.x = x;\n            this.y = y;\n\t\t}\n\t}\n\n\t/**\n\t * return the distance between this point and the given point\n\t * @param p {Point}\n\t * @return {number}\n\t */\n\tdistance(p) {\n\t\treturn Helper.distance(p.x, p.y, this.x, this.y);\n\t}\n};","/**\n * Created by ralphy on 04/09/17.\n *\n * @class Vector\n * @property {number} x\n * @property {number} y\n */\n\nconst Helper = require('./Helper.js');\n\nmodule.exports = class Vector {\n\t/**\n\t * The constructor accepts one two parameters\n\t * If one parameter is given, the constructor will consider it as\n\t * Vector and will build this vector accordingly.\n\t * If two parameters are given (both numbers), the constructor will initialize the x and y\n\t * components with these numbers.\n\t * if no parameters are given : the vector will be ZERO\n\t * @param (x) {Vector|number}\n\t * @param (y) {number}\n\t */\n\tconstructor(x, y) {\n\t\tif (x instanceof Vector) {\n\t\t\tthis.x = x.x;\n\t\t\tthis.y = x.y;\n\t\t} else {\n\t\t\tthis.x = x || 0;\n\t\t\tthis.y = y || 0;\n\t\t}\n\t}\n\n    /**\n\t * Mutable !\n\t * Modifie x et y\n     * @param x\n     * @param y\n     */\n\tset(x, y) {\n\t\tif (x instanceof Vector) {\n\t\t\treturn this.set(x.x, x.y);\n\t\t}\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Immutable !\n\t * returns a new Vector which is the sum of this instance + the given argument\n\t * @param v {Vector}\n\t * @returns {Vector}\n\t */\n\tadd(v) {\n\t\treturn new Vector(v.x + this.x, v.y + this.y);\n\t}\n\n\t/**\n\t * Immutable !\n\t * returns a new Vector which is the diffrence of this instance and the given argument\n\t * @param v\n\t */\n\tsub(v) {\n\t\treturn new Vector(this.x - v.x, this.y - v.y);\n\t}\n\n\t/**\n\t * Immutable !\n\t * returns a scalar product\n\t * multiplies the vector components by a given value -(vector or number)\n\t * @param f {Vector|number}\n\t * @returns {Vector|number}\n\t */\n\tmul(f) {\n\t\tif (f instanceof Vector) {\n\t\t\treturn this.x * f.x + this.y * f.y;\n\t\t} else if (typeof f === 'number') {\n\t\t\treturn new Vector(this.x * f, this.y * f);\n\t\t} else {\n\t\t\tthrow new Error('vector product accepts only vectors or number as parameter');\n\t\t}\n\t}\n\n\t/**\n\t * return the vector distance\n\t * @return {number}\n\t */\n\tdistance() {\n\t\treturn Helper.distance(0, 0, this.x, this.y);\n\t}\n\n\t/**\n\t * returns a normalized version of this vector\n\t * @return {Vector}\n\t */\n\tnormalize() {\n\t\treturn this.mul(1 / this.distance());\n\t}\n\n\t/**\n\t * returns a zero vector\n\t * @returns {Vector}\n\t */\n\tstatic zero() {\n\t\treturn new Vector(0, 0);\n\t}\n\n    /**\n\t * Mutable\n\t * Addition mutable des composante du vecteur\n     * @param v {Vector}\n     */\n\ttranslate(v) {\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\treturn this;\n\t}\n\n    /**\n     * Mutable\n     * Multiplication mutable des composante du vecteur\n     * @param f {number}\n     */\n\tscale(f) {\n\t\tthis.x *= f;\n\t\tthis.y *= f;\n\t\treturn this;\n\t}\n\n    /**\n\t * Renvoie l'angle entre le vecteur et l'axe X\n\t * si le vecteur est dans la direction x+ alors l'angle = 0\n     */\n\tangle() {\n\t\treturn Helper.angle(0, 0, this.x, this.y);\n\t}\n\n\ttoString() {\n\t\treturn [this.x, this.y].map(n => n.toString()).join(':');\n\t}\n\n\tfromPolar(a, s) {\n\t\tlet v = Helper.polar2rect(a, s);\n\t\tthis.set(v.dx, v.dy);\n\t\treturn this;\n\t}\n};","const Helper = require('./Helper');\nconst Point = require('./Point');\nconst Vector = require('./Vector');\n\nmodule.exports = {\n\tHelper,\n\tPoint,\n\tVector\n};","const geometry = require('./geometry');\nconst algorithms = require('./algorithms');\nconst SpellBook = require('./SpellBook');\nconst Random = require('./Random');\nconst Rainbow = require('./Rainbow');\nconst Emitter = require('./Emitter');\nconst collider = require('./collider');\nconst structures = require('./structures');\n\nmodule.exports = {\n\n\t// namespaces\n\talgorithms,\n\tcollider,\n\tgeometry,\n\tstructures,\n\n\t// classes\n\tSpellBook,\n\tRandom,\n\tRainbow,\n\tEmitter\n};","const o876 = require('./index');\n\nwindow.O876 = o876;\n","/**\n * @class Grid\n * This class is a generic grid containing anything\n * When new items are needed (when the grid changes size and gets larger)\n * an event is fired : \"rebuild\" which can be handled to construct cell content.\n */\nconst sb = require('../SpellBook');\nconst Emitter = require('../Emitter');\n\nmodule.exports = class Grid {\n\tconstructor() {\n        this._cells = null;\n        this._width = 0;\n        this._height = 0;\n        this.emitter = new Emitter();\n\t}\n\n    on() { this.emitter.on(...arguments); return this; }\n    off() { this.emitter.off(...arguments); return this; }\n    one() { this.emitter.one(...arguments); return this; }\n    trigger() { this.emitter.trigger(...arguments); return this; }\n\n\n    /**\n\t * Setter/Getter for a dimensionnal array of cells, wich represents the grid content.\n     * @param (x) {array}\n     * @return {Grid|array}\n     */\n\tcells(x) {\n        if (x !== undefined) {\n            this._height = x.length;\n            if (this._height) {\n            \tthis._width = x[0].length;\n\t\t\t} else {\n                this._width = 0;\n\t\t\t}\n        }\n\t\treturn sb.prop(this, '_cells', x);\n\t}\n\n    /**\n     * Setter/Getter for the grid width.\n\t * setting a new width will rebuild the grid\n     * @param (w) {number}\n     * @return {Grid|number}\n     */\n    width(w) {\n\t\tif (w !== undefined) {\n\t\t\tthis._rebuild(w, this._height);\n\t\t}\n        return sb.prop(this, '_width', w);\n    }\n\n    /**\n     * Setter/Getter for the grid height.\n     * setting a new height will rebuild the grid\n     * @param (h) {number}\n     * @return {Grid|number}\n     */\n    height(h) {\n        if (h !== undefined) {\n            this._rebuild(this._width, h);\n        }\n        return sb.prop(this, '_height', h);\n    }\n\n    /**\n\t * Rebuilds the grid according to the given dimensions\n\t * @param w {number}\n\t * @param h {number}\n\t * @private\n\t * @return {array}\n\t */\n\t_rebuild(w, h) {\n\t\tlet g = [];\n\t\tlet x, y, aRow, data;\n\t\tfor (y = 0; y < h; y++) {\n\t\t\taRow = [];\n\t\t\tfor (x = 0; x < w; x++) {\n\t\t\t\tdata = {x: x, y: y, width: w, height: h, cell: null};\n\t\t\t\tthis.trigger('rebuild', data);\n\t\t\t\taRow.push(data.cell);\n\t\t\t}\n\t\t\tg.push(aRow);\n\t\t}\n\t\tthis._width = w;\n\t\tthis._height = h;\n\t\tthis.cells(g);\n\t}\n\n    /**\n\t * Sets/Gets a cell value given its coordinates\n     * @param x {number}\n     * @param y {number}\n     * @param (v) {*}\n     * @return {*}\n     */\n\tcell(x, y, v) {\n\t\tif (v === undefined) {\n\t\t\tif (y >= 0 && y >= 0 && y < this._height && x < this._width) {\n\t\t\t\treturn this._cells[y][x];\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} else {\n\t\t\tif (y >= 0 && y >= 0 && y < this._height && x < this._width) {\n\t\t\t\tthis._cells[y][x] = v;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t}\n};\n","const Grid = require('./Grid');\n\nmodule.exports = {\n    Grid\n};"],"sourceRoot":""}