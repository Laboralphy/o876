{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./examples/treasure-map/CanvasHelper.js","webpack:///./examples/treasure-map/PirateWorld.js","webpack:///./examples/treasure-map/ServiceWorkerIO.js","webpack:///./examples/treasure-map/WorldGenerator.js","webpack:///./examples/treasure-map/WorldTile.js","webpack:///./examples/treasure-map/main.js","webpack:///./examples/treasure-map/palette.js","webpack:///./node_modules/events/events.js","webpack:///./src/Emitter.js","webpack:///./src/Rainbow.js","webpack:///./src/Random.js","webpack:///./src/SpellBook.js","webpack:///./src/algorithms/Astar/Astar.js","webpack:///./src/algorithms/Astar/Nood.js","webpack:///./src/algorithms/Astar/NoodList.js","webpack:///./src/algorithms/Astar/index.js","webpack:///./src/algorithms/Bresenham.js","webpack:///./src/algorithms/Easing.js","webpack:///./src/algorithms/Perlin.js","webpack:///./src/algorithms/SquareSpiral.js","webpack:///./src/algorithms/UnivGeneList.js","webpack:///./src/algorithms/index.js","webpack:///./src/collider/Collider.js","webpack:///./src/collider/Dummy.js","webpack:///./src/collider/Sector.js","webpack:///./src/collider/index.js","webpack:///./src/geometry/Helper.js","webpack:///./src/geometry/Point.js","webpack:///./src/geometry/Vector.js","webpack:///./src/geometry/View.js","webpack:///./src/geometry/index.js","webpack:///./src/index.js","webpack:///./src/structures/Cache2D.js","webpack:///./src/structures/Grid.js","webpack:///./src/structures/TileLayer.js","webpack:///./src/structures/index.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;AClFA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,8B;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iEAAiE,yBAAyB;AAC1F;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,+BAA+B,0BAA0B;AACzD;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB;AACjB,qBAAqB,OAAO;AAC5B,sBAAsB;AACtB,uBAAuB,OAAO;AAC9B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6B;;;;;;;;;;;AC9JA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B,SAAS,gBAAgB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,uBAAuB;AACpE,IAAI;AACJ,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA,iC;;;;;;;;;;;AC7GA;AACA;AACA;;AAEA;AACA,cAAc,qCAAqC;AACnD;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB;AACjB,qBAAqB,OAAO;AAC5B,0BAA0B,OAAO;AACjC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gC;;;;;;;;;;;ACrPA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B,oBAAoB,kBAAkB;AACtC,4BAA4B,MAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB;AACA;;AAEA,2B;;;;;;;;;;;ACjPA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,iBAAiB,4CAA4C;AAC7D,kBAAkB,2CAA2C;AAC7D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;;;;;;;;;;;;AC3FA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,kC;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;AC7SA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,EAAE;AACrB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB,qBAAqB;AACrB,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB,qBAAqB;AACrB,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB,wBAAwB;AACxB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB,wBAAwB;AACxB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB,wBAAwB;AACxB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;;;;AC7HA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA,0CAA0C,IAAI,aAAa,IAAI,aAAa,IAAI;AAChF;AACA,cAAc;AACd,MAAM;AACN,wCAAwC,IAAI,aAAa,IAAI,aAAa,IAAI;AAC9E;AACA,eAAe;AACf,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,K;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnWA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC,mBAAmB,OAAO;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,6BAA6B;AAC7B,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,mCAAmC,GAAG;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB,yBAAyB,QAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC5IA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,iBAAiB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,iBAAiB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;AAGA;;;AAGA,2B;;;;;;;;;;;AC9KA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,UAAU,+BAA+B,aAAa;AACtD,WAAW,gCAAgC,aAAa;AACxD,WAAW,gCAAgC,aAAa;AACxD,eAAe,oCAAoC,aAAa;;AAEhE;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,mBAAmB,OAAO;AAC1B,gBAAgB;AAChB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB;AACnB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB;AAChB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB;AAChB,aAAa;AACb;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxQA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;AClBA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd,cAAc;AACd,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd,cAAc;AACd,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd,cAAc;AACd,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd,cAAc;AACd,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,E;;;;;;;;;;;ACtFA;;AAEA;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,aAAa;AAC7E;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;;;;AC/KA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,U;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,kBAAkB,OAAO;AACzB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,kBAAkB,OAAO;AACzB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA;;AAEA;AACA;AACA;AACA;;AAEA,aAAa,OAAO;AACpB;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA,sCAAsC,cAAc;AACpD;AACA;AACA;;AAEA,cAAc,OAAO;AACrB;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA,I;AACA;AACA,aAAa,OAAO;AACpB;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8CAA8C,2BAA2B,EAAE;AAC3E;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,MAAM;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;AAGA;;AAEA,wB;;;;;;;;;;;AC7TA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gBAAgB;AACtC,uBAAuB,gBAAgB;AACvC;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9DA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qBAAqB;AACpD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8B;;;;;;;;;;;ACnHA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,aAAa;AACb;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;;;;ACpHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,E;;;;;;;;;;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;;;;;;;;;;;;;AChDA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,E;;;;;;;;;;;ACRA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe;AACf,eAAe,OAAO;AACtB,eAAe;AACf,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,kBAAkB,OAAO;AACzB,kBAAkB,OAAO;AACzB,kBAAkB,OAAO;AACzB,kBAAkB,OAAO;AACzB,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB,kBAAkB;AAClB,kBAAkB;AAClB,kBAAkB;AAClB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,E;;;;;;;;;;;AClEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd,aAAa;AACb;AACA;AACA;AACA;AACA,E;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd,cAAc;AACd;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;;;;ACjJA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;ACpCA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yB;;;;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU,+BAA+B,aAAa;AACtD,WAAW,gCAAgC,aAAa;AACxD,WAAW,gCAAgC,aAAa;AACxD,eAAe,oCAAoC,aAAa;;;AAGhE;AACA;AACA,mBAAmB;AACnB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB;AACnB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB;AACnB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd,cAAc;AACd;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA,cAAc,OAAO;AACrB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB,mBAAmB;AACnB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,KAAK;AACnB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,KAAK;AACnB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,SAAS;AAC9B,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzKA;AACA;AACA;;AAEA;AACA;AACA,E","file":"examples-treasure-map.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./examples/treasure-map/main.js\");\n","class CanvasHelper {\n    /**\n     * fabrique et renvoie un canvas\n     * @param w {number} taille\n     * @param h {number} taille\n     * @return {HTMLCanvasElement}\n     * @private\n     */\n    static create(w, h) {\n        let c = document.createElement('canvas');\n        c.width = w;\n        c.height = h;\n        return c;\n    }\n\n    static clone(c) {\n        let oCanvas = CanvasHelper.create(c.width, c.height);\n        oCanvas.getContext('2d').drawImage(c, 0, 0);\n    }\n\n    static draw(oDest, oSource, x, y) {\n        if (oSource) {\n\t\t\toDest.getContext('2d').drawImage(oSource, x, y);\n        }\n    }\n}\n\nmodule.exports = CanvasHelper;","const WorldGenerator = require('./WorldGenerator');\nconst o876 = require('../../src');\nconst ServiceWorkerIO = require('./ServiceWorkerIO');\nconst CanvasHelper = require('./CanvasHelper');\nconst WorldTile = require('./WorldTile');\n\nconst CLUSTER_SIZE = 16;\n\nclass PirateWorld {\n\tconstructor(wgd) {\n\t\tthis.oWorldDef = wgd;\n\t\tthis._cache = new o876.structures.Cache2D({size: 64});\n        this._service = new ServiceWorkerIO();\n        this._service.service(wgd.service);\n        this._service.emit('init', {\n        \tseed: wgd.seed,\n\t\t\tcell: wgd.cellSize,\n\t\t\tcluster: CLUSTER_SIZE,\n\t\t\thexCluster: wgd.hexSize\n        });\n\n        this._xView = null;\n        this._yView = null;\n\t\tthis._fetching = false;\n\t}\n\n\tview(oCanvas, x, y) {\n\t\tif (!this._fetching) {\n\t\t\tthis._fetching = true;\n\t\t\tthis.preloadTiles(x, y, oCanvas.width, oCanvas.height).then(({tileFetched, timeElapsed}) => {\n\t\t\t\tthis._fetching = false;\n\t\t\t\tif (tileFetched) {\n\t\t\t\t\tconsole.log('fetched', tileFetched, 'tiles in', timeElapsed, 's.', (tileFetched * 10 / timeElapsed | 0) / 10, 'tiles/s');\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tthis._xView = x;\n\t\tthis._yView = y;\n\t\tthis.renderTiles(oCanvas, x, y);\n\t}\n\n\tcellSize() {\n\t\treturn this.oWorldDef.cellSize;\n\t}\n\n\n\tasync fetchTile(x, y) {\n\t\treturn new Promise(resolve => {\n\t\t\t// verification en cache\n\t\t\tlet oWorldTile = new WorldTile(x, y, this.cellSize(), {\n\t\t\t\tdrawGrid: this.oWorldDef.drawGrid,\n\t\t\t\tdrawCoords: this.oWorldDef.drawCoords\n\t\t\t});\n\t\t\tthis._cache.push(x, y, oWorldTile).forEach(wt => !!wt && (typeof wt.free === 'function') && wt.free());\n\t\t\toWorldTile.lock();\n\t\t\tthis._service.emit('tile', {...oWorldTile.getCoords()}, result => {\n\t\t\t\toWorldTile.colormap = result.tile.colormap;\n\t\t\t\toWorldTile.physicmap = result.tile.physicmap;\n\t\t\t\toWorldTile.unlock();\n\t\t\t\tresolve(oWorldTile);\n\t\t\t});\n\t\t});\n\t}\n\n\tasync preloadTiles(x, y, w, h) {\n\t\tlet tStart = performance.now();\n\t\tlet cellSize = this.cellSize();\n\t\tlet m = PirateWorld.getViewPointMetrics(x, y, w, h, cellSize, this.oWorldDef.preload);\n\t\tlet yTilePix = 0;\n\t\tlet nTileCount = (m.yTo - m.yFrom + 1) * (m.xTo - m.xFrom + 1);\n\t\tlet iTile = 0;\n\t\tlet nTileFetched = 0;\n\t\tlet promises = [];\n\t\tfor (let yTile = m.yFrom; yTile <= m.yTo; ++yTile) {\n\t\t\tif (y & 1 === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet xTilePix = 0;\n\t\t\tfor (let xTile = m.xFrom; xTile <= m.xTo; ++xTile) {\n\t\t\t\tlet wt = this._cache.getPayload(xTile, yTile);\n\t\t\t\tif (!wt) {\n\t\t\t\t\t// pas encore créée\n\t\t\t\t\tconsole.log('fetching tiles', (100 * iTile / nTileCount | 0).toString() + '%');\n\t\t\t\t\t++nTileFetched;\n\t\t\t\t\tpromises.push(this.fetchTile(xTile, yTile));\n\t\t\t\t}\n\t\t\t\t// si la tile est partiellement visible il faut la dessiner\n\t\t\t\txTilePix += cellSize;\n\t\t\t\t++iTile;\n\t\t\t}\n\t\t\tyTilePix += cellSize;\n\t\t}\n\t\tawait Promise.all(promises);\n\t\treturn {\n\t\t\ttileFetched: nTileFetched,\n\t\t\ttimeElapsed: (performance.now() - tStart | 0) / 1000\n\t\t};\n\t}\n\n\trenderTiles(oCanvas, x, y) {\n\t\tlet w = oCanvas.width;\n\t\tlet h = oCanvas.height;\n\t\tlet cellSize = this.cellSize();\n\t\tlet m = PirateWorld.getViewPointMetrics(x, y, w, h, cellSize, 0);\n\t\tlet yTilePix = 0;\n\t\tfor (let yTile = m.yFrom; yTile <= m.yTo; ++yTile) {\n\t\t\tlet xTilePix = 0;\n\t\t\tfor (let xTile = m.xFrom; xTile <= m.xTo; ++xTile) {\n\t\t\t\tlet wt = this._cache.getPayload(xTile, yTile);\n\t\t\t\tif (wt) {\n\t\t\t\t\tlet xScreen = m.xOfs + xTilePix;\n\t\t\t\t\tlet yScreen = m.yOfs + yTilePix;\n\t\t\t\t\t// si la tile est partiellement visible il faut la dessiner\n\t\t\t\t\tif (!wt.isPainted() && wt.isMapped()) {\n\t\t\t\t\t\tconsole.log('painting tile', xTile, yTile);\n\t\t\t\t\t\twt.paint();\n\t\t\t\t\t\twt.colormap = null;\n\t\t\t\t\t}\n\t\t\t\t\tif (wt.isPainted() && wt.isMapped()) {\n\t\t\t\t\t\tCanvasHelper.draw(oCanvas, wt.canvas, xScreen, yScreen);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\txTilePix += cellSize;\n\t\t\t}\n\t\t\tyTilePix += cellSize;\n\t\t}\n    }\n\n    /**\n\t * A partire d'une coordonée centrée sur un rectangle de longueur et largeur spécifiées\n\t * determiner les différente coordonnée de tuiles à calculer\n     * @param x {number} coordonnée du centre du view point\n     * @param y {number}\n     * @param width {number} taille du viewpoint\n     * @param height {number}\n     * @param nBorder {number} taille de la bordure de securité\n     * @return {{xFrom: number, yFrom: number, xTo: *, yTo: *, xOfs: number, yOfs: number}}\n     */\n\tstatic getViewPointMetrics(x, y, width, height, cellSize, nBorder) {\n        let x0 = x - (width >> 1);\n        let y0 = y - (height >> 1);\n        let xFrom = Math.floor(x0 / cellSize) - nBorder;\n        let yFrom = Math.floor(y0 / cellSize) - nBorder;\n        let xTo = Math.floor((x0 + width - 1) / cellSize) + (nBorder);\n        let yTo = Math.floor((y0 + height - 1) / cellSize) + (nBorder);\n        let xOfs = WorldGenerator._mod(x0, cellSize);\n        let yOfs = WorldGenerator._mod(y0, cellSize);\n\t\treturn {\n\t\t\txFrom,\n\t\t\tyFrom,\n\t\t\txTo,\n\t\t\tyTo,\n\t\t\txOfs: -xOfs - nBorder * cellSize,\n\t\t\tyOfs: -yOfs - nBorder * cellSize\n\t\t};\n\t}\n}\n\nmodule.exports = PirateWorld;","const EventManager = require('events');\n\n\nclass ServiceWorkerIO {\n\n\tconstructor() {\n\t\tthis._callbacks = {};\n\t\tthis._bLog = false;\n\t\tthis._callbackLastId = 0;\n\t\tthis._worker = null;\n\t\tthis._eventManager = new EventManager();\n\t}\n\n\tverbose() {\n\t    this._bLog = true;\n    }\n\n\tstatic _encode(x) {\n\t\treturn x;\n\t}\n\n\tstatic _decode(x) {\n\t\treturn x;\n\t}\n\n\t/**\n\t * si un paramètre (w est spécifié : Déclare cette instance en tant que qu'utilisatrice de service\n\t * sinon : déclare cette instance en tant que service\n\t * Initialise l'écouteur de message en fonction du contexte sélectionné\n\t * @param [w] {string} nom du service à utiliser\n\t */\n\tservice(w) {\n\t\tif (w) {\n\t\t\tthis._worker = new Worker(w);\n\t\t\tthis._worker.addEventListener('message', event => this.messageReceived(ServiceWorkerIO._decode(event.data)));\n\t\t} else {\n\t\t\taddEventListener('message', event => this.messageReceived(ServiceWorkerIO._decode(event.data)));\n\t\t}\n\t}\n\n\n\tregisterCallback(callback) {\n\t\tthis._callbacks[++this._callbackLastId] = callback;\n\t\treturn this._callbackLastId;\n\t}\n\n\tinvokeCallback(id, data) {\n\t\tthis.log('invoking callback id', id);\n\t\tif (id in this._callbacks) {\n\t\t\tlet cb = this._callbacks[id];\n\t\t\tdelete this._callbacks[id];\n\t\t\tcb(data);\n\t\t} else {\n\t\t\tif (id < this._callbackLastId) {\n\t\t\t\tthrow new Error('this callback id has expired')\n\t\t\t} else {\n\t\t\t\tthrow new Error('this callback has invalid id that has never been used');\n\t\t\t}\n\t\t}\n\t}\n\n\ton(...args) {\n\t\tthis._eventManager.on(...args);\n\t}\n\n\t/**\n\t * Transmission d'info à l'interlocuteur\n\t */\n\temit(sEvent, data, callback) {\n\t\tlet packet = Object.assign({}, data, {__event: sEvent});\n\t\tif (callback) {\n\t\t\tpacket.__callback = this.registerCallback(callback);\n\t\t}\n\t\tthis.log('emitting message', sEvent, packet);\n\t\tif (this._worker) {\n\t\t\tthis._worker.postMessage(ServiceWorkerIO._encode(packet));\n\t\t} else {\n\t\t\tpostMessage(ServiceWorkerIO._encode(packet));\n\t\t}\n\t}\n\n\tlog(...args) {\n\t\tif (this._bLog) {\n\t\t    console.log(!!this._worker ? '[window]' : '[service]', ...args);\n        }\n\t}\n\n\tmessageReceived(data) {\n\t\tthis.log('message received', data);\n\t\tlet sEvent = data.__event;\n\t\tlet idCallback = data.__callback;\n\t\tlet idResponse = data.__response;\n\n\t\tdelete data.__event;\n\t\tdelete data.__callback;\n\t\tdelete data.__response;\n\t\tif (idCallback) {\n\t\t\tthis._eventManager.emit(sEvent, data, result => {\n\t\t\t\tthis.log('response', sEvent, 'callback', idCallback, result);\n\t\t\t\tthis.emit(sEvent, Object.assign(result, {__response: idCallback}));\n\t\t\t});\n\t\t} else if (idResponse) {\n\t\t\tthis.invokeCallback(idResponse, data);\n\t\t} else {\n\t\t\tthis._eventManager.emit(sEvent, data);\n\t\t}\n\t}\n}\n\nmodule.exports = ServiceWorkerIO;","const o876 = require('../../src');\nconst Perlin = o876.algorithms.Perlin;\nconst GRADIENT = require('./palette');\n\nclass WorldGenerator {\n\tconstructor({cellSize, clusterSize, seed, hexSize}) {\n\t\tlet pcell = new Perlin();\n\t\tpcell.size(cellSize);\n\t\tpcell.seed(seed);\n\n\n\t\tlet pclust = new Perlin();\n\t\tpclust.size(clusterSize);\n\t\tpclust.seed(seed);\n\n\t\t// les cellule, détail jusqu'au pixel\n\t\t// défini l'élévaltion finale du terrain\n\t\tthis._perlinCell = pcell;\n\n\t\t// les cluster, détail jusqu'au cellule\n\t\t// défini l'élévation de base de la cellule correspondante\n\t\tthis._perlinCluster = pclust;\n\t\tthis._cache = new o876.structures.Cache2D({size: 64});\n\t\tthis._hexSize = hexSize;\n\t}\n\n\tstatic _mod(n, d) {\n\t\treturn o876.SpellBook.mod(n, d);\n\t}\n\n\t/**\n\t * Génération d'un cluster\n\t * @param x {number} coordonnées\n\t * @param y {number} du cluster\n\t */\n\tgenerateCluster(x, y) {\n\t\treturn this._perlinCluster.generate(x, y);\n\t}\n\n\n\t_cellFilter15(base, value) {\n\t\tif (base < 0.5) {\n\t\t\treturn value * base;\n\t\t} else {\n\t\t\treturn Math.min(0.99, value * base * 1.5) ;\n\t\t}\n\t}\n\n\t_cellFilterBinary(base, value) {\n\t\tif (base < 0.5) {\n\t\t\treturn value * 0.5;\n\t\t} else {\n\t\t\treturn value * 0.5 + 0.5;\n\t\t}\n\t}\n\n\t_cellFilterMed(base, value) {\n\t\treturn (base + value) / 2;\n\t}\n\n\t_cellFilterMinMax(base, value) {\n\t\tif (base < 0.45) {\n\t\t\treturn base * value;\n\t\t} else {\n\t\t\treturn Math.max(0, Math.min(0.99, 1.333333333 * (base - value / 4)));\n\t\t}\n\t}\n\n\t_cellDepthModulator(x, y, xg, yg, meshSize) {\n\t\tlet c = 6;\n\t\tlet bInHexagon = this._isOnHexaMesh(xg, yg, meshSize, c);\n\t\tif (!bInHexagon) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (this._isOnHexaMesh(xg, yg, meshSize, c >> 2)) {\n\t\t\treturn 0.333;\n\t\t} else if (this._isOnHexaMesh(xg, yg, meshSize, c >> 1)) {\n\t\t\treturn 0.555;\n\t\t} else {\n\t\t\treturn 0.777;\n\t\t}\n\t}\n\n\n    /**\n     * Renvoie true si le point spécifié se trouve sur les lignes d'un maillage hexagonal\n     * @param x {number} coordonnées du point à tester\n     * @param y {number}\n     * @param nSize {number} taille du maillage\n     * @param nThickness {number} épaisseur des ligne du maillage\n     * @returns {boolean}\n     */\n    _isOnHexaMesh(x, y, nSize, nThickness) {\n        const lte = (n, a) => (n - nThickness) <= a * nSize;\n        const gte = (n, a) => (n + nThickness) >= a * nSize;\n        const lt = (n, a) => (n + nThickness) < a * nSize;\n        const gt = (n, a) => (n - nThickness) > a * nSize;\n        const bte = (n, a, b) => gte(n, a) && lte(n, b);\n        const bt = (n, a, b) => gt(n, a) && lt(n, b);\n        const ar = (a, b) => Math.abs(a - b) < nThickness;\n        const mod = o876.SpellBook.mod;\n\n        let s2 = 2 * nSize;\n        let s4 = 4 * nSize;\n        let s6 = 6 * nSize;\n        let s8 = 8 * nSize;\n\n        let ymod6 = mod(y, s6);\n\n        let xmod4 = mod(x, s4);\n        let xmod6 = mod(x, s6);\n        let xmod8 = mod(x, s8);\n\n\t\tconst TRIPLE_HEXA = true;\n\n        // permet de créer des zone triple-hexa pour faire varier la continentalité\n        if (TRIPLE_HEXA && bt(xmod8, 2, 5) && bte(ymod6 - nThickness, 2, 5)) {\n            return false;\n        }\n        // permet de créer des zone triple-hexa pour faire varier la continentalité\n        if (TRIPLE_HEXA && bt(xmod8, 4, 6) && bte(ymod6 - nThickness, 2, 5)) {\n            return false;\n        }\n\n        if ((lte(xmod4, 0) || gte(xmod4, 4)) && bte(ymod6, 2, 4)) {\n            return true;\n        }\n        if (bte(xmod4, 2, 2) && (bte(ymod6, 0, 1) || bte(ymod6, 5, 6))) {\n            return true;\n        }\n\n        let p6 = mod(Math.floor(0.5 * x), s6);\n        let p6i = mod(Math.floor(-0.5 * x), s6);\n\n        let q60 = ymod6;\n        let q62 = mod(y + s2, s6);\n        let q64 = mod(y + s4, s6);\n\n\n        if (bte(xmod6, 0, 2) && (ar(p6, q62) || ar(p6i, q64))) {\n            return true;\n        }\n\n        if (bte(xmod6, 2, 4) && (ar(p6, q60) || ar(p6i, q60))) {\n            return true;\n        }\n\n        if (bte(xmod6, 4, 6) && (ar(p6, q64) || ar(p6i, q62))) {\n            return true;\n        }\n\n        return false;\n    }\n\n    _cellProcess(xPix, yPix, xg, yg, base, cell) {\n        return this._cellFilterMinMax(base, cell) *\n            this._cellDepthModulator(xPix, yPix, xg, yg, this._hexSize);\n    }\n\n    /**\n     * Permet d'indexer des zone physique de terrain (déduite à partir de l'altitude min et l'altitude max\n     * @param data\n     * @param meshSize\n     * @returns {Array}\n     */\n    buildCellPhysicMap(data, meshSize) {\n        let aMap = [];\n        function disc(n) {\n            if (n < 0.5) {\n                return 1;\n            }\n            if (n < 0.65) {\n                return 2;\n            }\n            if (n < 0.75) {\n                return 3;\n            }\n            if (n < 0.85) {\n                return 4;\n            }\n            return 5;\n        }\n        data.forEach((row, y) => {\n            let yMesh = Math.floor(y / meshSize);\n            if (!aMap[yMesh]) {\n                aMap[yMesh] = [];\n            }\n            row.forEach((cell, x) => {\n                let xMesh = Math.floor(x / meshSize);\n                if (!aMap[yMesh][xMesh]) {\n                    aMap[yMesh][xMesh] = {\n                        min: 5,\n                        max: 0,\n                        type: 0\n                    };\n                }\n                let m = aMap[yMesh][xMesh];\n                m.min = Math.min(m.min, cell);\n                m.max = Math.max(m.max, cell);\n                m.type = disc(m.min) * 10 + disc(m.max);\n            });\n        });\n        return aMap;\n    }\n\n    computeCell(xCurs, yCurs) {\n        const MESH_SIZE = 16;\n        let clusterSize = this._perlinCluster.size();\n        let heightMap = this._perlinCell.generate(\n            xCurs,\n            yCurs, {\n                noise: (xg, yg, cellData) => {\n                    let xCluster = Math.floor(xg / clusterSize);\n                    let yCluster = Math.floor(yg / clusterSize);\n                    let xClusterMod = WorldGenerator._mod(xg, clusterSize);\n                    let yClusterMod = WorldGenerator._mod(yg, clusterSize);\n                    let data = this.generateCluster(xCluster, yCluster);\n                    return cellData.map((row, y) =>\n                        row.map((cell, x) =>\n                            this._cellProcess(x, y, xg, yg, data[yClusterMod][xClusterMod], cell)\n                        )\n                    );\n                }\n            }\n        );\n        let colorMap = Perlin.colorize(heightMap, GRADIENT);\n        let physicMap = this.buildCellPhysicMap(heightMap, MESH_SIZE);\n        return {\n            x: xCurs,\n            y: yCurs,\n            colormap: colorMap,\n            physicmap: physicMap\n        };\n\t}\n\n\tcomputeCellCache(xCurs, yCurs) {\n\t\tlet payload = this._cache.getPayload(xCurs, yCurs);\n\t\tif (!payload) {\n\t\t\tpayload = this.computeCell(xCurs, yCurs);\n            this._cache.push(xCurs, yCurs, payload).forEach(wt => !!wt && (typeof wt.free === 'function') && wt.free());\n\t\t}\n\t\treturn payload;\n\t}\n}\n\nmodule.exports = WorldGenerator;","const o876 = require('../../src');\nconst CanvasHelper = require('./CanvasHelper');\nconst Perlin = o876.algorithms.Perlin;\nconst Rainbow = o876.Rainbow;\n\n/**\n * Construction des clipart utilisé pour égayer la map\n * @private\n */\nfunction _buildCliparts() {\n    let cliparts = {};\n    const MESH_SIZE = 16;\n    const WAVE_SIZE = 3;\n    const HERB_SIZE = 3;\n    const MNT_LENGTH = 7;\n    const MNT_HEIGHT = MNT_LENGTH | 0.75 | 0;\n    const FOREST_SIZE = 4;\n    let xMesh = MESH_SIZE >> 1;\n    let yMesh = MESH_SIZE >> 1;\n    let c, ctx;\n\n    // vague\n    c = CanvasHelper.create(MESH_SIZE, MESH_SIZE);\n    ctx = c.getContext('2d');\n    ctx.fillStyle = 'rgba(57, 25, 7, 0.2)';\n    ctx.strokeStyle = 'rgba(154, 117, 61, 0.75)';\n    ctx.lineWidth = 1.2;\n    ctx.beginPath();\n    ctx.moveTo(xMesh - WAVE_SIZE, yMesh + WAVE_SIZE);\n    ctx.lineTo(xMesh, yMesh);\n    ctx.lineTo(xMesh + WAVE_SIZE, yMesh + WAVE_SIZE);\n    ctx.stroke();\n    cliparts.wave = c;\n\n    // forest\n    c = CanvasHelper.create(MESH_SIZE, MESH_SIZE);\n    ctx = c.getContext('2d');\n    ctx.fillStyle = 'rgba(57, 25, 7, 0.2)';\n    ctx.strokeStyle = 'rgba(154, 117, 61, 0.75)';\n    ctx.lineWidth = 1.2;\n    ctx.beginPath();\n    ctx.arc(xMesh, yMesh,FOREST_SIZE, 0, Math.PI * 2);\n    ctx.rect(xMesh - 1, yMesh + FOREST_SIZE, 2, FOREST_SIZE);\n    ctx.fill();\n    ctx.stroke();\n    cliparts.forest = c;\n\n    // herbe\n    c = CanvasHelper.create(MESH_SIZE, MESH_SIZE);\n    ctx = c.getContext('2d');\n    ctx.fillStyle = 'rgba(57, 25, 7, 0.2)';\n    ctx.strokeStyle = 'rgba(154, 117, 61, 0.75)';\n    ctx.lineWidth = 1.2;\n    ctx.beginPath();\n    ctx.moveTo(xMesh - HERB_SIZE, yMesh - HERB_SIZE);\n    ctx.lineTo(xMesh, yMesh);\n    ctx.lineTo(xMesh + HERB_SIZE, yMesh - HERB_SIZE);\n    ctx.stroke();\n    cliparts.grass = c;\n\n    // Montagne\n    c = CanvasHelper.create(MESH_SIZE, MESH_SIZE);\n    ctx = c.getContext('2d');\n    ctx.fillStyle = 'rgba(57, 25, 7, 0.2)';\n    ctx.strokeStyle = 'rgba(154, 117, 61, 0.75)';\n    ctx.lineWidth = 1.2;\n    let g = ctx.createLinearGradient(xMesh, 0, MESH_SIZE, MESH_SIZE);\n    g.addColorStop(0, 'rgba(154, 117, 61, 1)');\n    g.addColorStop(1, 'rgba(154, 117, 61, 0.5)');\n    ctx.fillStyle = g;\n    ctx.moveTo(xMesh, yMesh);\n    ctx.beginPath();\n    ctx.lineTo(xMesh + MNT_LENGTH, yMesh + MNT_HEIGHT);\n    ctx.lineTo(xMesh, yMesh + (MNT_HEIGHT * 0.75 | 0));\n    ctx.lineTo(xMesh + (MNT_LENGTH * 0.25 | 0), yMesh + (MNT_HEIGHT * 0.4 | 0));\n    ctx.lineTo(xMesh, yMesh);\n    ctx.closePath();\n    ctx.fill();\n    ctx.beginPath();\n    ctx.moveTo(xMesh, yMesh);\n    ctx.lineTo(xMesh + MNT_LENGTH, yMesh + MNT_HEIGHT);\n    ctx.moveTo(xMesh, yMesh);\n    ctx.lineTo(xMesh, yMesh + (MNT_HEIGHT >> 1));\n    ctx.moveTo(xMesh, yMesh);\n    ctx.lineTo(xMesh - MNT_LENGTH, yMesh + MNT_HEIGHT);\n    ctx.stroke();\n    cliparts.mount = c;\n    return cliparts;\n}\n\nconst CLIPARTS = _buildCliparts();\nconst MESH_SIZE = 16;\n\n\n/**\n * classe de gestion des tuiles, coté window\n * cette classe a une propriété canvas et doit resté coté window\n */\n\nclass WorldTile {\n    constructor(x, y, size, options) {\n        if (size === undefined || y === undefined || x === undefined) {\n            throw new Error('world tile construction requires coords x y and size. !')\n        }\n        this.x = x;\n        this.y = y;\n        this.size = size;\n        this.colormap = null;\n        this.physicmap = null;\n        this.canvas = null;\n        this._lock = false;\n        this.options = options;\n    }\n\n    free() {\n        this.canvas = null;\n        this.physicmap = null;\n        this.colormap = null;\n    }\n\n    lock() {\n        this._lock = true;\n    }\n\n    unlock() {\n        this._lock = false;\n    }\n\n    isLocked() {\n        return this._lock;\n    }\n\n    isMapped() {\n        return this.physicmap != null;\n    }\n\n    isPainted() {\n        return this.canvas != null;\n    }\n\n\n\n    /**\n     * dessine des element de terrain (arbre, montagnes)\n     * @param xCurs {number} coordonnées cellule concernée\n     * @param yCurs {number} coordonnées cellule concernée\n     * @param tile {HTMLCanvasElement} canvas de sortie\n     * @param aHeightIndex {array} height map fourie par WorldGenerator\n     */\n    paintTerrainType() {\n        let tile = this.canvas;\n        let physicmap = this.physicmap;\n        let ctx = tile.getContext('2d');\n        ctx.font = '12px italic serif';\n        ctx.textBaseline = 'top';\n        physicmap.forEach((row, y) => row.forEach((cell, x) => {\n            if ((x & 1) ^ (y & 1)) {\n                switch (cell.type) {\n                    case 11: // vague\n                        ctx.drawImage(CLIPARTS.wave, x * MESH_SIZE, y * MESH_SIZE);\n                        break;\n\n                    case 23: // herbe\n                        ctx.drawImage(CLIPARTS.grass, x * MESH_SIZE, y * MESH_SIZE);\n                        break;\n\n                    case 33: // foret\n                        ctx.drawImage(CLIPARTS.forest, x * MESH_SIZE, y * MESH_SIZE);\n                        break;\n\n                    case 55: // montagne\n                        ctx.drawImage(CLIPARTS.mount, x * MESH_SIZE, y * MESH_SIZE);\n                        break;\n                }\n            }\n        }));\n    }\n\n    paintLinesCoordinates() {\n        let xCurs = this.x;\n        let yCurs = this.y;\n        let tile = this.canvas;\n        let ctx = tile.getContext('2d');\n\t\tif (this.options.drawGrid) {\n\t\t\tctx.strokeStyle = 'rgba(57, 25, 7, 0.5)';\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(0, tile.height - 1);\n\t\t\tctx.lineTo(0, 0);\n\t\t\tctx.lineTo(tile.width - 1, 0);\n\t\t\tctx.stroke();\n\t\t}\n\t\tif (this.options.drawCoords) {\n\t\t    let sText;\n\t\t\tctx.font = 'italic 12px serif';\n\t\t\tctx.textBaseline = 'top';\n\t\t\tctx.strokeStyle = '#efce8c';\n\t\t\tctx.fillStyle = 'rgba(57, 25, 7)';\n\t\t\tif (xCurs & 1) {\n\t\t\t\tsText = 'lat:  ' + yCurs.toString();\n\t\t\t\tctx.strokeText(sText, 25, 4);\n\t\t\t\tctx.fillText(sText, 25, 4);\n\t\t\t}\n\t\t\tif (yCurs & 1) {\n\t\t\t\tsText = 'long:  ' + xCurs.toString();\n\t\t\t\tctx.save();\n\t\t\t\tctx.rotate(-Math.PI / 2);\n\t\t\t\tctx.strokeText(sText, -tile.width + 25, 4);\n\t\t\t\tctx.fillText(sText, -tile.width + 25, 4);\n\t\t\t\tctx.restore();\n\t\t\t}\n        }\n    }\n\n\n    /**\n     * lorsque la cellule à été générée par le WorldGenerator\n     * on peut la transformer en canvas par cette methode\n     */\n    paint() {\n        let xCurs = this.x;\n        let yCurs = this.y;\n        let colormap = this.colormap;\n        let physicmap = this.physicmap;\n        let cellSize = this.size;\n        let tile = CanvasHelper.create(cellSize, cellSize);\n        this.canvas = tile;\n        let ctx = tile.getContext('2d');\n        let oImageData = ctx.createImageData(tile.width, tile.height);\n        let buffer32 = new Uint32Array(oImageData.data.buffer);\n        colormap.forEach((x, i) => buffer32[i] = x);\n        ctx.putImageData(oImageData, 0, 0);\n        this.paintTerrainType(xCurs, yCurs, tile, physicmap);\n        this.paintLinesCoordinates(xCurs, yCurs, tile, physicmap);\n        return tile;\n    }\n\n    getCoords() {\n        return {x: this.x, y: this.y};\n    }\n}\n\nmodule.exports = WorldTile;","const o876 = require('../../src');\nconst PirateWorld = require('./PirateWorld');\nconst CanvasHelper = require('./CanvasHelper');\n\n\nfunction kbHandler(event) {\n\tswitch (event.key) {\n\t\tcase 'ArrowUp':\n\t\t\tpwrunner.view(document.querySelector('.world'), X, Y -= 16);\n\t\t\tbreak;\n\n\t\tcase 'ArrowDown':\n\t\t\tpwrunner.view(document.querySelector('.world'), X, Y += 16);\n\t\t\tbreak;\n\n\t\tcase 'ArrowLeft':\n\t\t\tpwrunner.view(document.querySelector('.world'), X -= 16, Y);\n\t\t\tbreak;\n\n\t\tcase 'ArrowRight':\n\t\t\tpwrunner.view(document.querySelector('.world'), X += 16, Y);\n\t\t\tbreak;\n\n\t\tcase ' ':\n\t\t\tbFreeze = !bFreeze;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tconsole.log('key', event.key);\n\t\t\tbreak;\n\t}\n}\n\nlet pwrunner, X, Y, bFreeze = false;\n\nfunction main4() {\n\tpwrunner = this.world = new PirateWorld({\n\t\tcellSize: 256,\n\t\tseed: 0.111,\n\t\tpreload: 1,\n\t\tdrawGrid: true,\n\t\tdrawCoords: true,\n\t\tservice: '../../dist/examples-treasure-map-service.js'\n\t});\n\twindow.addEventListener('keydown', kbHandler);\n\twindow.pwrunner = pwrunner;\n\tX = 1000 * 256;\n\tY = 0;\n\tlet cvs = document.querySelector('.world');\n\tpwrunner.preloadTiles(X, Y, cvs.width, cvs.height).then(() => {\n\t\tconsole.log('starting scrolling');\n\t\tsetInterval(() => {\n\t\t\tif (!bFreeze) {\n\t\t\t\tX += 2;\n\t\t\t\tY++;\n\t\t\t}\n\t\t\tpwrunner.view(cvs, X, Y);\n\t\t}, 32);\n\t});\n}\n\n\nfunction main3() {\n\tpwrunner = this.world = new PirateWorld({\n\t\tcellSize: 16,\n\t\thexSize: 16,\n\t\tseed: 0.111,\n\t\tpreload: 2,\n\t\tdrawGrid: false,\n\t\tdrawCoords: false,\n\t\tservice: '../../dist/examples-treasure-map-service.js'\n\t});\n\n\tX = 960;\n\tY = -40;\n\tasync function fetchAndRenderTiles(oCanvas, xTile, yTile) {\n\t\tfor (let y = 0; y < (oCanvas.height / pwrunner.cellSize()); ++y) {\n\t\t\tfor (let x = 0; x < (oCanvas.width / pwrunner.cellSize()); ++x) {\n\t\t\t\tlet wt = await pwrunner.fetchTile(X + x + xTile, Y + y + yTile);\n\t\t\t\twt.paint();\n\t\t\t\tCanvasHelper.draw(oCanvas, wt.canvas, (x + xTile) * pwrunner.cellSize(), (y + yTile) * pwrunner.cellSize());\n\t\t\t}\n\t\t}\n\t}\n\n\tlet cvs = document.querySelector('.world');\n\tfetchAndRenderTiles(cvs, 0, 0).then(() => console.log('done.'));\n}\n\n\n\nwindow.addEventListener('load', main3);\n","const o876 = require('../../src');\nconst Rainbow = o876.Rainbow;\n\nfunction _buildGradient() {\n    return Rainbow.gradient({\n        0: '#dec673',\n        40: '#efd69c',\n        48: '#d6a563',\n        50: '#572507',\n        55: '#d2a638',\n        75: '#b97735',\n        99: '#efce8c'\n    })\n        .map(x => Rainbow.parse(x))\n        .map(x => x.r | x.g << 8 | x.b << 16 | 0xFF000000);\n}\n\nmodule.exports = _buildGradient();","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n","/**\n * Created by ralphy on 07/09/17.\n */\n\nconst SB = require('./SpellBook');\n/**\n * this class is similar to the node.js Emitter system\n * it emits events\n * client instances may instanciate this class and call methods such as\n * .on  to defines an event handler\n * .off to undefined an event handler\n * .one to define a \"one triggered\" handler\n * .trigger to cast an event\n *\n * Only usefull in javascript, as node.js is provided with the \"events\" module.\n */\n\n\nmodule.exports = class Emitter {\n    constructor() {\n        this._oEventHandlers = {};\n    }\n\n    /**\n\t * triggers an event\n\t * @param sEvent {string} event name\n\t * @param params {*} any parameter that will transmitted to the handler\n     * @return {*}\n     */\n    trigger(sEvent, params) {\n        let aArgs = SB.array(arguments);\n        aArgs.shift();\n        let eh = this._oEventHandlers;\n        if (sEvent in eh) {\n\t\t\teh[sEvent].one.forEach(f => f.apply(this, aArgs));\n\t\t\teh[sEvent].one = [];\n            eh[sEvent].on.forEach(f => f.apply(this, aArgs));\n        }\n\t\treturn this;\n    }\n\n    /**\n\t * A private helper to define a handler\n     * @param sEvent {string}\n     * @param sType {string}\n     * @param pHandler {function}\n     * @private\n     */\n\t_define(sEvent, sType, pHandler) {\n\t\tlet eh = this._oEventHandlers;\n\t\tif (!(sEvent in eh)) {\n\t\t\teh[sEvent] = {\n\t\t\t    on: [],\n                one: []\n            };\n\t\t}\n\t\teh[sEvent][sType].push(pHandler);\n\t}\n\n    /**\n\t * a private method to undefined an event\n     * @param sEvent {string}\n     * @param sType {string}\n     * @param pHandler ({function})\n     * @private\n     */\n\t_undefine(sEvent, sType, pHandler) {\n\t\tlet eh = this._oEventHandlers;\n\t\tif (!(sEvent in eh)) {\n\t\t\treturn;\n\t\t}\n\t\teh = eh[sEvent];\n\t\tif (!(sType in eh)) {\n\t\t\treturn;\n\t\t}\n\t\tif (pHandler) {\n\t\t\teh[sType] = eh[sType].filter(h => h !== pHandler);\n        } else {\n\t\t\teh[sType] = [];\n        }\n\t}\n\n    /**\n\t * Defines an event handler, that will be invoked each time the event is triggered\n     * @param sEvent {string}\n     * @param pHandler {function}\n     * @return {Emitter}\n     */\n\ton(sEvent, pHandler) {\n\t\tthis._define(sEvent, 'on', pHandler);\n\t\treturn this;\n\t}\n\n    /**\n     * Defines an event handler, that will be invoked only the next time\n\t * the event will be triggered\n     * @param sEvent {string}\n     * @param pHandler {function}\n     * @return {Emitter}\n     */\n\tone(sEvent, pHandler) {\n\t\tthis._define(sEvent, 'one', pHandler);\n\t\treturn this;\n\t}\n\n    /**\n\t * unload event handlers\n     * @param sEvent {string}\n     * @param pHandler {function}\n     * @return {Emitter}\n     */\n\toff(sEvent, pHandler) {\n        switch (SB.typeMap(arguments)) {\n            case 's': // turn off handler\n\t\t\t\tthis._undefine(sEvent, 'on');\n\t\t\t\tthis._undefine(sEvent, 'one');\n\t\t\t\tbreak;\n\n            case 'sf':\n\t\t\t\tthis._undefine(sEvent, 'on', pHandler);\n\t\t\t\tthis._undefine(sEvent, 'one', pHandler);\n\t\t\t\tbreak;\n        }\n\t\treturn this;\n\t}\n};","/**\n * @class O876.Rainbow\n * Rainbow - Color Code Convertor Boîte à outil graphique\n * O876 raycaster project\n * 2012-01-01 Raphaël Marandet\n * good to GIT\n */\n\nconst COLORS = {\n\taliceblue : '#F0F8FF',\n\tantiquewhite : '#FAEBD7',\n\taqua : '#00FFFF',\n\taquamarine : '#7FFFD4',\n\tazure : '#F0FFFF',\n\tbeige : '#F5F5DC',\n\tbisque : '#FFE4C4',\n\tblack : '#000000',\n\tblanchedalmond : '#FFEBCD',\n\tblue : '#0000FF',\n\tblueviolet : '#8A2BE2',\n\tbrown : '#A52A2A',\n\tburlywood : '#DEB887',\n\tcadetblue : '#5F9EA0',\n\tchartreuse : '#7FFF00',\n\tchocolate : '#D2691E',\n\tcoral : '#FF7F50',\n\tcornflowerblue : '#6495ED',\n\tcornsilk : '#FFF8DC',\n\tcrimson : '#DC143C',\n\tcyan : '#00FFFF',\n\tdarkblue : '#00008B',\n\tdarkcyan : '#008B8B',\n\tdarkgoldenrod : '#B8860B',\n\tdarkgray : '#A9A9A9',\n\tdarkgrey : '#A9A9A9',\n\tdarkgreen : '#006400',\n\tdarkkhaki : '#BDB76B',\n\tdarkmagenta : '#8B008B',\n\tdarkolivegreen : '#556B2F',\n\tdarkorange : '#FF8C00',\n\tdarkorchid : '#9932CC',\n\tdarkred : '#8B0000',\n\tdarksalmon : '#E9967A',\n\tdarkseagreen : '#8FBC8F',\n\tdarkslateblue : '#483D8B',\n\tdarkslategray : '#2F4F4F',\n\tdarkslategrey : '#2F4F4F',\n\tdarkturquoise : '#00CED1',\n\tdarkviolet : '#9400D3',\n\tdeeppink : '#FF1493',\n\tdeepskyblue : '#00BFFF',\n\tdimgray : '#696969',\n\tdimgrey : '#696969',\n\tdodgerblue : '#1E90FF',\n\tfirebrick : '#B22222',\n\tfloralwhite : '#FFFAF0',\n\tforestgreen : '#228B22',\n\tfuchsia : '#FF00FF',\n\tgainsboro : '#DCDCDC',\n\tghostwhite : '#F8F8FF',\n\tgold : '#FFD700',\n\tgoldenrod : '#DAA520',\n\tgray : '#808080',\n\tgrey : '#808080',\n\tgreen : '#008000',\n\tgreenyellow : '#ADFF2F',\n\thoneydew : '#F0FFF0',\n\thotpink : '#FF69B4',\n\tindianred  : '#CD5C5C',\n\tindigo  : '#4B0082',\n\tivory : '#FFFFF0',\n\tkhaki : '#F0E68C',\n\tlavender : '#E6E6FA',\n\tlavenderblush : '#FFF0F5',\n\tlawngreen : '#7CFC00',\n\tlemonchiffon : '#FFFACD',\n\tlightblue : '#ADD8E6',\n\tlightcoral : '#F08080',\n\tlightcyan : '#E0FFFF',\n\tlightgoldenrodyellow : '#FAFAD2',\n\tlightgray : '#D3D3D3',\n\tlightgrey : '#D3D3D3',\n\tlightgreen : '#90EE90',\n\tlightpink : '#FFB6C1',\n\tlightsalmon : '#FFA07A',\n\tlightseagreen : '#20B2AA',\n\tlightskyblue : '#87CEFA',\n\tlightslategray : '#778899',\n\tlightslategrey : '#778899',\n\tlightsteelblue : '#B0C4DE',\n\tlightyellow : '#FFFFE0',\n\tlime : '#00FF00',\n\tlimegreen : '#32CD32',\n\tlinen : '#FAF0E6',\n\tmagenta : '#FF00FF',\n\tmaroon : '#800000',\n\tmediumaquamarine : '#66CDAA',\n\tmediumblue : '#0000CD',\n\tmediumorchid : '#BA55D3',\n\tmediumpurple : '#9370DB',\n\tmediumseagreen : '#3CB371',\n\tmediumslateblue : '#7B68EE',\n\tmediumspringgreen : '#00FA9A',\n\tmediumturquoise : '#48D1CC',\n\tmediumvioletred : '#C71585',\n\tmidnightblue : '#191970',\n\tmintcream : '#F5FFFA',\n\tmistyrose : '#FFE4E1',\n\tmoccasin : '#FFE4B5',\n\tnavajowhite : '#FFDEAD',\n\tnavy : '#000080',\n\toldlace : '#FDF5E6',\n\tolive : '#808000',\n\tolivedrab : '#6B8E23',\n\torange : '#FFA500',\n\torangered : '#FF4500',\n\torchid : '#DA70D6',\n\tpalegoldenrod : '#EEE8AA',\n\tpalegreen : '#98FB98',\n\tpaleturquoise : '#AFEEEE',\n\tpalevioletred : '#DB7093',\n\tpapayawhip : '#FFEFD5',\n\tpeachpuff : '#FFDAB9',\n\tperu : '#CD853F',\n\tpink : '#FFC0CB',\n\tplum : '#DDA0DD',\n\tpowderblue : '#B0E0E6',\n\tpurple : '#800080',\n\trebeccapurple : '#663399',\n\tred : '#FF0000',\n\trosybrown : '#BC8F8F',\n\troyalblue : '#4169E1',\n\tsaddlebrown : '#8B4513',\n\tsalmon : '#FA8072',\n\tsandybrown : '#F4A460',\n\tseagreen : '#2E8B57',\n\tseashell : '#FFF5EE',\n\tsienna : '#A0522D',\n\tsilver : '#C0C0C0',\n\tskyblue : '#87CEEB',\n\tslateblue : '#6A5ACD',\n\tslategray : '#708090',\n\tslategrey : '#708090',\n\tsnow : '#FFFAFA',\n\tspringgreen : '#00FF7F',\n\tsteelblue : '#4682B4',\n\ttan : '#D2B48C',\n\tteal : '#008080',\n\tthistle : '#D8BFD8',\n\ttomato : '#FF6347',\n\tturquoise : '#40E0D0',\n\tviolet : '#EE82EE',\n\twheat : '#F5DEB3',\n\twhite : '#FFFFFF',\n\twhitesmoke : '#F5F5F5',\n\tyellow : '#FFFF00',\n\tyellowgreen : '#9ACD32'\n};\n\nmodule.exports = class Rainbow {\n\n\t/** \n\t * Fabrique une chaine de caractère représentant une couleur au format CSS\n\t * @param xData une structure {r: int, g: int, b: int, a: float}\n\t * @return code couleur CSS au format rgb(r, g, b) ou rgba(r, g, b, a)\n\t */\n\tstatic rgba(xData) {\n\t\treturn Rainbow._buildRGBAFromStructure(Rainbow.parse(xData));\n\t}\n\t\n\t/**\n\t * Analyse une valeur d'entrée pour construire une structure avec les \n\t * composantes \"r\", \"g\", \"b\", et eventuellement \"a\".\n\t */ \n\tstatic parse(xData) {\n\t\tif (typeof xData === \"object\") {\n\t\t\treturn xData;\n\t\t} else if (typeof xData === \"number\") {\n\t\t\treturn Rainbow._buildStructureFromInt(xData);\n\t\t} else if (typeof xData === \"string\") {\n\t\t\txData = xData.toLowerCase();\n\t\t\tif (xData in COLORS) {\n\t\t\t\txData = COLORS[xData];\n\t\t\t}\n\t\t\tswitch (xData.length) {\n\t\t\t\tcase 3:\n\t\t\t\t\treturn Rainbow._buildStructureFromString3(xData);\n\t\t\t\t\t\n\t\t\t\tcase 4:\n\t\t\t\t\tif (xData[0] === '#') {\n\t\t\t\t\t\treturn Rainbow._buildStructureFromString3(xData.substr(1));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error('invalid color structure');\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\tcase 6:\n\t\t\t\t\treturn Rainbow._buildStructureFromString6(xData);\n\t\t\t\t\t\n\t\t\t\tcase 7:\n\t\t\t\t\tif (xData[0] === '#') {\n\t\t\t\t\t\treturn Rainbow._buildStructureFromString6(xData.substr(1));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error('invalid color structure');\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\tdefault:\n\t\t\t\t\tlet rx = xData.match(/^rgb\\( *([0-9]{1,3}) *, *([0-9]{1,3}) *, *([0-9]{1,3}) *\\)$/);\n\t\t\t\t\tif (rx) {\n\t\t\t\t\t\treturn {r: rx[1] | 0, g: rx[2] | 0, b: rx[3] | 0};\n\t\t\t\t\t} else {\n\t\t\t\t\t\trx = xData.match(/^rgba\\( *([0-9]{1,3}) *, *([0-9]{1,3}) *, *([0-9]{1,3}) *, *([.0-9]+) *\\)$/);\n\t\t\t\t\t\tif (rx) {\n\t\t\t\t\t\t\treturn {r: rx[1] | 0, g: rx[2] | 0, b: rx[3] | 0, a: parseFloat(rx[4])};\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new Error('invalid color structure ' + xData);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * Génère un spectre entre deux valeurs de couleurs\n\t * La fonction renvoi \n\t */\n\tstatic spectrum(sColor1, sColor2, nSteps) {\n\t\tlet c1 = Rainbow.parse(sColor1);\n\t\tlet c2 = Rainbow.parse(sColor2);\n\t\t\n\t\tlet nSecur = 100;\n\t\t\n\t\tfunction getMedian(x1, x2) {\n\t\t\tif (x1 === undefined) {\n\t\t\t\tthrow new Error('first color is undefined');\n\t\t\t}\n\t\t\tif (x2 === undefined) {\n\t\t\t\tthrow new Error('second color is undefined');\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tr: (x1.r + x2.r) >> 1,\n\t\t\t\tg: (x1.g + x2.g) >> 1,\n\t\t\t\tb: (x1.b + x2.b) >> 1\n\t\t\t};\t\t\t\n\t\t}\n\t\t\n\t\tfunction fillArray(a, x1, x2, n1, n2) {\n\t\t\tlet m = getMedian(x1, x2);\n\t\t\tlet n = (n1 + n2) >> 1;\n\t\t\tif (--nSecur < 0) {\n\t\t\t\treturn a;\n\t\t\t}\n\t\t\tif (Math.abs(n1 - n2) > 1) {\n\t\t\t\tfillArray(a, x1, m, n1, n);\n\t\t\t\tfillArray(a, m, x2, n, n2);\n\t\t\t}\n\t\t\ta[n1] = x1;\n\t\t\ta[n2] = x2;\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\treturn fillArray([], c1, c2, 0, nSteps - 1).map(function(c) {\n\t\t\treturn Rainbow.rgba(c);\n\t\t}, this);\n\t}\n\t\n\t/**\n\t * Generate a gradient\n\t * @param oPalette palette definition\n\t * \n\t * {\n\t * \t\tstart: value,\n\t * \t\tstop1: value,\n\t * \t\tstop2: value,\n\t * \t\t...\n\t * \t\tstopN: value,\n\t * \t\tend: value\n\t * },\n\t * \n\t * example :\n\t * {\n\t * \t\t0: '#00F',\n\t * \t\t50: '#FF0',\n\t * \t\t100: '#F00'\n\t * }\n\t * rappel : une palette d'indices de 0 à 100 dispose de 101 entrée\n\t */\n\tstatic gradient(oPalette) {\n\t\tlet aPalette = [];\n\t\tlet sColor;\n\t\tlet sLastColor = null;\n\t\tlet nPal;\n\t\tlet nLastPal = 0;\n\t\tfor (let iPal in oPalette) {\n\t\t\tnPal = iPal | 0;\n\t\t\tsColor = oPalette[iPal];\n\t\t\tif (sLastColor !== null) {\n\t\t\t\taPalette = aPalette.concat(Rainbow.spectrum(sLastColor, sColor, nPal - nLastPal + 1).slice(1));\n\t\t\t} else {\n\t\t\t\taPalette[nPal] = Rainbow.rgba(sColor);\n\t\t\t}\n\t\t\tsLastColor = sColor;\n\t\t\tnLastPal = nPal;\n\t\t}\n\t\treturn aPalette;\n\t}\n\n\tstatic _buildStructureFromInt(n) {\n\t\tlet r = (n >> 16) & 0xFF;\n\t\tlet g = (n >> 8) & 0xFF;\n\t\tlet b = n & 0xFF;\n\t\treturn {r: r, g: g, b: b};\n\t}\n\t\n\tstatic _buildStructureFromString3(s) {\n\t\tlet r = parseInt('0x' + s[0] + s[0]);\n\t\tlet g = parseInt('0x' + s[1] + s[1]);\n\t\tlet b = parseInt('0x' + s[2] + s[2]);\n\t\treturn {r: r, g: g, b: b};\n\t}\n\n\tstatic _buildStructureFromString6(s) {\n\t\tlet r = parseInt('0x' + s[0] + s[1]);\n\t\tlet g = parseInt('0x' + s[2] + s[3]);\n\t\tlet b = parseInt('0x' + s[4] + s[5]);\n\t\treturn {r: r, g: g, b: b};\n\t}\n\n\tstatic _buildRGBAFromStructure(oData) {\n\t\tlet s1 = 'rgb';\n\t\tlet s2 = oData.r.toString() + ', ' + oData.g.toString() + ', ' + oData.b.toString();\n\t\tif ('a' in oData) {\n\t\t\ts1 += 'a';\n\t\t\ts2 += ', ' + oData.a.toString();\n\t\t}\n\t\treturn s1 + '(' + s2 + ')';\n\t}\n\t\n\tstatic _buildString3FromStructure(oData) {\n\t\tlet sr = ((oData.r >> 4) & 0xF).toString(16);\n\t\tlet sg = ((oData.g >> 4) & 0xF).toString(16);\n\t\tlet sb = ((oData.b >> 4) & 0xF).toString(16);\n\t\treturn sr + sg + sb;\n\t}\n\n\tstatic byte(n) {\n\t\treturn Math.min(255, Math.max(0, n | 0));\n\t}\n\n\tstatic brightness(color, f) {\n\t\tlet c = Rainbow.parse(color);\n\t\tc.r = Rainbow.byte(f * c.r);\n\t\tc.g = Rainbow.byte(f * c.g);\n\t\tc.b = Rainbow.byte(f * c.b);\n\t\treturn c;\n\t}\n};\n","/**\n * @class O876.Random\n * a FALSE random very false...\n * generated random numbers, with seed\n * used for predictable landscape generation\n */\n\nconst SB = require('./SpellBook');\n\nmodule.exports = class Random {\n\n\tconstructor() {\n        this._seed = Math.random();\n\t}\n\n    /**\n\t * Will define a new seed\n     * @param x {number}\n     * @returns {*}\n     */\n\tseed(x) {\n    \treturn SB.prop(this, '_seed', x);\n\t}\n\n    /**\n\t * Return a random generated number using the simple sine-66 function\n     * @returns {number} a number between 0 and 1\n     * @private\n     */\n\t_rand() {\n\t\treturn this._seed = Math.abs(((Math.sin(this._seed) * 1e12) % 1e6) / 1e6);\n\t}\n\n    /**\n\t * returns a random generated number.\n\t * the result will vary according to the given parameter values\n\t * - two integer (a, b) gives a random number between a and b\n\t * - an array gives a random item of this array\n\t * - an object gives a random key of this object\n\t * - no parameter gives a random float value between 0 and 1\n     * @param [a] {number|Array|Object} lower limit\n     * @param [b] {number} upper limit\n     * @returns {*}\n     */\n\trand(a, b) {\n\t\tlet r = this._rand();\n\t\tswitch (typeof a) {\n\t\t\tcase \"undefined\":\n\t\t\t\treturn r;\n\t\t\t\t\n\t\t\tcase \"number\":\n\t\t\t\tif (b === undefined) {\n\t\t\t\t\tb = a - 1;\n\t\t\t\t\ta = 0;\n\t\t\t\t}\n\t\t\t\treturn Math.max(a, Math.min(b, (b - a + 1) * r + a | 0));\n\t\t\t\n\t\t\tcase \"object\":\n\t\t\t\tif (Array.isArray(a)) {\n\t\t\t\t\tif (a.length > 0) {\n\t\t\t\t\t\treturn a[r * a.length | 0];\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn this.rand(Object.keys(a));\n\t\t\t\t}\n\t\t\t\t\n\t\t\tdefault:\n\t\t\t\treturn r;\n\t\t}\n\t}\n\n    /**\n     * This function will randomly pick an item ffrom the given array.\n     * This choice is influenced by a weight.\n     * The weight is either the item value or the result of a function called back with\n     * the item given as parameter.\n     * ex : chooseFate([10, 60, 30]) will give :\n     *  - 0 : 10% of chance\n     *  - 1 : 60% of chance\n     *  - 2 : 40% of chance\n     *\n     * @param aArray {array}\n     * @param pProbFunction {function}\n     * @return {number} the rank of the chosen item\n     */\n    chooseFate(aArray, pProbFunction) {\n        let nSum;\n        if (pProbFunction) {\n            nSum = aArray.reduce((p, c) => Math.max(0, pProbFunction(c)) + p, 0);\n        } else {\n            nSum = aArray.reduce((p, c) => Math.max(0, c) + p, 0);\n        }\n        let nChoice = this.rand(0, nSum - 1);\n        for (let i = 0, l = aArray.length; i < l; ++i) {\n            let ci;\n            if (pProbFunction) {\n                ci = Math.max(0, pProbFunction(aArray[i]));\n            } else {\n                ci = Math.max(0, aArray[i]);\n            }\n            if (nChoice < ci) {\n                return i;\n            }\n            nChoice -= ci;\n        }\n        return null;\n    }\n\n    /**\n     * Shuffles array in place. ES6 version\n     * @param {Array} aArray items The array containing the items.\n     * @param {boolean} bImmutable if true, a new array is built, the provide array remains untouched\n     */\n    shuffle(aArray, bImmutable) {\n        if (bImmutable) {\n            aArray = aArray.slice(0);\n        }\n        for (let i = aArray.length; i; --i) {\n            let j = this.rand(i);\n            [aArray[i - 1], aArray[j]] = [aArray[j], aArray[i - 1]];\n        }\n        return aArray;\n    }\n\n    /**\n     * randomly pick an item from an array or a string\n     * @param aArray {array|string}\n     * @param [bRemove] {boolean} if true the item is removed from the array\n     */\n    randPick(aArray, bRemove) {\n        let n = this.rand(aArray.length);\n        let r = aArray[n];\n        if (bRemove) {\n            aArray.splice(n, 1);\n        }\n        return r;\n    }\n\n};\n","/**\n * Created by ralphy on 07/09/17.\n */\n\nclass SpellBook {\n    /**\n     * Turns an array-like-structure into an array (a real one)\n     */\n    static array(subject) {\n        const LENGTH_PROPERTY = 'length';\n        if (Array.isArray(subject)) {\n            return subject;\n        }\n        if (typeof subject === 'object') {\n            // is there a length property ?\n            let bLength = LENGTH_PROPERTY in subject;\n            // extracting keys minus \"length\" property\n            let aKeys = Object\n                .keys(subject)\n                .filter(k => k !== LENGTH_PROPERTY);\n            if (aKeys.some(k => isNaN(k))) {\n                return false;\n            }\n            if ((bLength) && (subject[LENGTH_PROPERTY] !== aKeys.length)) {\n                return false;\n            }\n            if (aKeys\n                .map(k => parseInt(k))\n                .sort((k1, k2) => k1 - k2)\n                .every((k, i) => k === i)) {\n                return bLength\n                    ? Array.prototype.slice.call(subject, 0)\n                    : aKeys.map(k => subject[k]);\n            }\n        }\n        return false;\n    }\n\n    static catsortArray(aInput, {cat, sort = null}) {\n    \tlet oOutput = {};\n    \taInput.forEach(e => {\n    \t\tlet sCat = cat(e);\n    \t\tif (!(sCat in oOutput)) {\n    \t\t\toOutput[sCat] = [];\n\t\t\t}\n\t\t\toOutput[sCat].push(e);\n\t\t});\n    \tif (typeof sort === 'function') {\n\t\t\tfor (let sCat in oOutput) {\n\t\t\t\toOutput[sCat] = oOutput[sCat].sort(sort)\n\t\t\t}\n\t\t}\n\t\treturn oOutput;\n\t}\n\n\t/**\n\t * élimine tout les doubloons de l'array spécifié. Ne modifie par l'array, mais renvoie un nouveau tableau\n\t * @param aArray\n\t * @returns {*}\n\t */\n\tstatic uniqArray(aArray) {\n    \treturn aArray.filter((x, i, a) => a.indexOf(x) === i)\n\t}\n\n    /**\n     * quickly clones an array into a new one\n     * this method is mainly used for turning \"arguments\" pseudo array into a real array\n     * @param a {Array|Object}\n     * @return {Array}\n     */\n    static cloneArray(a) {\n        return Array.prototype.slice.call(a, 0)\n    }\n\n\t/**\n\t * Renvoie le type d'une variable (différencie les Tableau Array des objet}\n\t * @param x {*}\n\t * @returns {string}\n\t */\n\tstatic typeof(x) {\n\t\tlet tx = (typeof x);\n\t\tswitch (tx) {\n\t\t\tcase 'object':\n\t\t\t\tif (x === null) {\n\t\t\t\t\treturn 'u';\n\t\t\t\t} else if (Array.isArray(x)) {\n\t\t\t\t\treturn 'a';\n\t\t\t\t} else {\n\t\t\t\t\treturn 'o';\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn tx.charAt(0);\n\t\t}\n\t}\n\n    /**\n     * maps an array into a string\n     * converting all elements into there \"type\" counterpart.\n     * any number element will be turned into \"n\"\n     * any object element will be turned into \"o\"\n     * this method is used to quickly switch-case an array according to its elements types.\n     *\n     * example : [222, \"abc\", [1,2,3], null, {x: 1.00, y: 3.00}]\n     * will produce : \"nsauo\"\n     * n: number\n     * s: string\n     * b: boolean\n     * o: object\n     * a: real array\n     * f: function\n     * u: undefined / null\n     *\n     * @param aArgs\n     * @return {string}\n     */\n    static typeMap(aArgs) {\n\t\treturn this.cloneArray(aArgs).map(function(x) {\n\t\t\treturn SpellBook.typeof(x);\n\t\t}).join('');\n    }\n\n\t/**\n     * Parse a search string (?variable=value)\n     * @param sSearch {string} as in window.search\n\t * @returns {{}}\n\t */\n\tstatic parseSearch(sSearch) {\n\t\tif (sSearch) {\n\t\t\tlet nQuest = sSearch.indexOf('?');\n\t\t\tif (nQuest >= 0) {\n\t\t\t\tsSearch = sSearch.substr(nQuest + 1);\n\t\t\t} else {\n\t\t\t\treturn {};\n\t\t\t}\n\t\t} else {\n\t\t\tsSearch = window.location.search.substr(1);\n\t\t}\n\t\tlet match,\n\t\t\tpl     = /\\+/g,  // Regex for replacing addition symbol with a space\n\t\t\tsearch = /([^&=]+)=?([^&]*)/g,\n\t\t\tquery  = sSearch,\n\t\t\t_decode = function(s) {\n\t\t\t\treturn decodeURIComponent(s.replace(pl, ' '));\n\t\t\t};\n\t\tlet oURLParams = {};\n\t\twhile (match = search.exec(query)) {\n\t\t\toURLParams[_decode(match[1])] = _decode(match[2]);\n\t\t}\n\t\treturn oURLParams;\n\t}\n\n    static prop(oInstance, sProperty, value) {\n        if (value === undefined) {\n            return oInstance[sProperty];\n        } else {\n            oInstance[sProperty] = value;\n            return oInstance;\n        }\n    }\n\n    static mod(n, d) {\n        if (n > 0) {\n            return n % d;\n        } else {\n            return (d - (-n % d)) % d;\n        }\n    }\n\n\n};\n\n\nmodule.exports = SpellBook;","/**\n * Created by ralphy on 06/09/17.\n */\n\nconst Helper = require('../../geometry/Helper');\nconst Nood = require('./Nood');\nconst NoodList = require('./NoodList');\nconst Emitter = require('../../Emitter');\nconst Point = require('../../geometry/Point');\nconst SB = require('../../SpellBook');\n\n/**\n * @class\n * this class is an implementation of a-star path finding algorithm\n * how to use :\n * const pf = new Astar()\n * pf.init({\n * \tgrid: [[][]..] give a 2D array of cells here\n * \twalkable: code for walkable cell in the grid\n * \tdiagonals: true if you want to allow diagonal moves\n * \tmax: maximum iteration (act as watch dog)\n * })\n * pf.find(xfrom, yfrom, xto, yto)\n */\nmodule.exports = class Astar {\n\tconstructor() {\n\t\t// configuration\n\t\tthis._bUseDiagonals = false;\n        this._grid = null;\n        this._width = 0;\n        this._height = 0;\n\t\tthis.MAX_ITERATIONS = 4096;\n        this.GRID_BLOCK_WALKABLE = 0;\n\n\t\t// working objects and variables\n        this.oOpList = null;\n        this.oClList = null;\n        this.aPath = null;\n\t\tthis.nIterations = 0;\n\n\t\t// utilities\n\t\tthis.emitter = new Emitter();\n\t}\n\n    on() { this.emitter.on(...arguments); return this; }\n    off() { this.emitter.off(...arguments); return this; }\n    one() { this.emitter.one(...arguments); return this; }\n    trigger() { this.emitter.trigger(...arguments); return this; }\n\n    /**\n\t * modifies a cell value\n     */\n\t_setCell(x, y, n) {\n\t\tif (this._grid[y] !== undefined && this._grid[y][x] !== undefined) {\n\t\t\tthis._grid[y][x] = n;\n\t\t} else {\n\t\t\tthrow new Error(\n\t\t\t\t'Astar: writing tile out of Grid: ' + x + ', ' + y);\n\t\t}\n\t}\n\n\t_getCell(x, y) {\n\t\tif (this._grid[y]) {\n\t\t\tif (x < this._grid[y].length) {\n\t\t\t\treturn this._grid[y][x];\n\t\t\t}\n\t\t}\n\t\tthrow new Error('Astar: read tile out of Grid: ' + x + ', ' + y);\n\t}\n\n\t_isCellWalkable(x, y) {\n\t\ttry {\n\t\t\tlet r = {\n\t\t\t\twalkable: this._getCell(x, y) === this.GRID_BLOCK_WALKABLE,\n\t\t\t\tcell: {\n\t\t\t\t\tx: x,\n\t\t\t\t\ty: y\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis.trigger('walkable', r);\n\t\t\treturn r.walkable;\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t_closeNood(x, y) {\n\t\tlet n = this.oOpList.get(x, y);\n\t\tif (n) {\n\t\t\tthis.oClList.set(x, y, n);\n\t\t\tthis.oOpList.del(x, y);\n\t\t}\n\t}\n\n\t_addAdjacent(x, y, xArrival, yArrival) {\n\t\tlet i, j;\n\t\tlet i0, j0;\n\t\tlet oTmp;\n\t\tlet w = this._width, h = this._height, bDiag = this._bUseDiagonals;\n\t\tfor (i0 = -1; i0 <= 1; i0++) {\n\t\t\ti = x + i0;\n\t\t\tif ((i < 0) || (i >= w)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (j0 = -1; j0 <= 1; j0++) {\n\t\t\t\tif (!bDiag && (j0 * i0) !== 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tj = y + j0;\n\t\t\t\tif ((j < 0) || (j >= h)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ((i === x) && (j === y)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!this._isCellWalkable(i, j)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (!this.oClList.exists(i, j)) {\n\t\t\t\t\toTmp = new Nood();\n\t\t\t\t\toTmp.fGCost = this.oClList.get(x, y).fGCost\t+ Helper.distance(i, j, x, y);\n\t\t\t\t\toTmp.fHCost = Helper.distance(i, j, xArrival, yArrival);\n\t\t\t\t\toTmp.fFCost = oTmp.fGCost + oTmp.fHCost;\n\t\t\t\t\toTmp.oPos = new Point(i, j);\n\t\t\t\t\toTmp.oParent = new Point(x, y);\n\n\t\t\t\t\tif (this.oOpList.exists(i, j)) {\n\t\t\t\t\t\tif (oTmp.fFCost < this.oOpList.get(i, j).fFCost) {\n\t\t\t\t\t\t\tthis.oOpList.set(i, j, oTmp);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.oOpList.set(i, j, oTmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Recherche le meilleur noeud de la liste et le renvoi\n\t_bestNood(oList) {\n\t\tlet oBest = null;\n\t\tlet oNood;\n\n\t\tfor (let iNood in oList.oList) {\n\t\t\toNood = oList.oList[iNood];\n\t\t\tif (oBest === null) {\n\t\t\t\toBest = oNood;\n\t\t\t} else if (oNood.fFCost < oBest.fFCost) {\n\t\t\t\toBest = oNood;\n\t\t\t}\n\t\t}\n\t\treturn oBest;\n\t}\n\n    _buildPath(xTo, yTo) {\n        let oCursor = this.oClList.get(xTo, yTo);\n        if (oCursor !== null) {\n            while (!oCursor.isRoot()) {\n                this.aPath.unshift({\n                    x: oCursor.oPos.x,\n                    y: oCursor.oPos.y\n                });\n                oCursor = this.oClList.get(oCursor.oParent.x, oCursor.oParent.y);\n            }\n        }\n    }\n\n\tfind(xFrom, yFrom, xTo, yTo) {\n\t\tthis.reset();\n\t\tlet oBest;\n\t\tlet oDepart = new Nood();\n\t\toDepart.oPos = new Point(xFrom, yFrom);\n\t\toDepart.oParent = new Point(xFrom, yFrom);\n\t\tlet xCurrent = xFrom;\n\t\tlet yCurrent = yFrom;\n\t\tthis.oOpList.add(oDepart);\n\t\tthis._closeNood(xCurrent, yCurrent);\n\t\tthis._addAdjacent(xCurrent, yCurrent, xTo, yTo);\n\n\t\tlet iIter = 0, MAX = this.MAX_ITERATIONS;\n\n\t\twhile (!((xCurrent === xTo) && (yCurrent === yTo)) && (!this.oOpList.empty())) {\n\t\t\toBest = this._bestNood(this.oOpList);\n\t\t\tif (!oBest) {\n\t\t\t\t// could not find path\n                throw new Error('Astar: no path to destination');\n\t\t\t}\n\t\t\txCurrent = oBest.oPos.x;\n\t\t\tyCurrent = oBest.oPos.y;\n\t\t\tthis._closeNood(xCurrent, yCurrent);\n\t\t\tthis._addAdjacent(oBest.oPos.x, oBest.oPos.y, xTo, yTo);\n\t\t\tif (++iIter > MAX) {\n\t\t\t\tthrow new Error('Astar: too much iterations');\n\t\t\t}\n\t\t}\n\t\tif (this.oOpList.empty() && !((xCurrent === xTo) && (yCurrent === yTo))) {\n\t\t\tthrow new Error('Astar: no path to destination');\n\t\t}\n\t\tthis.nIterations = iIter;\n\t\tthis._buildPath(xTo, yTo);\n\t\treturn this.aPath;\n\t}\n\n    /**\n\t * Changes a cell value inside the grid\n     * @param x {number} cell coordinates\n     * @param y {number} cell coordinates\n     * @param (v) {number} new value\n     * @return {*}\n     */\n\tcell(x, y, v) {\n        if (v === undefined) {\n            return this._getCell(x, y);\n        } else {\n            this._setCell(x, y, v);\n            return this;\n        }\n    }\n\n    /**\n     * resets the grid\n     * @return {*}\n     */\n    reset() {\n        this.oOpList = new NoodList();\n        this.oClList = new NoodList();\n        this.aPath = [];\n        this.nIterations = 0;\n        return this;\n    }\n\n    /**\n     * Setter/Getter of the internal grid.\n     * @param (g) {[]}\n     * @return {[]|Astar}\n     */\n    grid(g) {\n        if (g !== undefined) {\n            this._height = g.length;\n            this._width = g[0].length;\n        }\n        return SB.prop(this, '_grid', g);\n    }\n\n\t/**\n\t * Setter/getter of the walkable code.\n\t * This code is use to determine if a grid cell is walkable or not.\n\t * @param (w) {string|number}\n\t * @return {string|number|Astar}\n\t */\n\twalkable(w) {\n\t\treturn SB.prop(this, 'GRID_BLOCK_WALKABLE', w);\n\t}\n\n\t/**\n\t * Setter/getter of the diagonal flag.\n\t * if set to true, the path finder will cross the grid diagonaly if needed.\n\t * @param (b) {boolean}\n\t * @return {boolean|Astar}\n\t */\n\tdiagonals(b) {\n\t\treturn SB.prop(this, '_bUseDiagonals', b);\n\t}\n};\n","/**\n * Created by ralphy on 04/09/17.\n */\n\nconst Point = require('../../geometry/Point.js');\n\nmodule.exports = class Nood {\n\tconstructor() {\n\t\tthis.fGCost = 0.0;\n\t\tthis.fHCost = 0.0;\n\t\tthis.fFCost = 0.0;\n\t\tthis.oParent = new Point(0, 0);\n\t\tthis.oPos = new Point(0, 0);\n\t}\n\n\tisRoot() {\n\t\treturn this.oParent.x === this.oPos.x && this.oParent.y === this.oPos.y;\n\t}\n};\n","/**\n * Created by ralphy on 06/09/17.\n */\n\n/**\n * The NoodList class is a simple class aimed at facilitating nood list manipulations\n */\nmodule.exports = class NoodList {\n\tconstructor() {\n\t\tthis.oList = {};\n\t}\n\n\t/**\n\t * adds an instance of Nood in the list\n\t * @param oNood\n\t */\n\tadd(oNood) {\n\t\tthis.set(oNood.oPos.x, oNood.oPos.y, oNood);\n\t}\n\n\t/**\n\t * Sets an instance of Nood in the list\n\t * a Nood is indexed by its position. Thus two Nood shall not have the same x and y pair\n\t * @param x {number}\n\t * @param y {number}\n\t * @param oNood {Nood}\n\t */\n\tset(x, y, oNood) {\n\t\tthis.oList[this.getKey(x, y)] = oNood;\n\t}\n\n\t/**\n\t * Returns the numbers of Nood in the list\n\t * @return {number}\n\t */\n\tcount() {\n\t\treturn Object(this.oList).length;\n\t}\n\n\t/**\n\t * Returns true if the spécified position (x, y) has a matching Nood in the list\n\t * @param x {number}\n\t * @param y {number}\n\t * @returns {boolean}\n\t */\n\texists(x, y) {\n\t\treturn this.getKey(x, y) in this.oList;\n\t}\n\n\t/**\n\t * Creates a key from an x and y values\n\t * @param x {number}\n\t * @param y {number}\n\t * @returns {string}\n\t */\n\tgetKey(x, y) {\n\t\treturn x.toString() + '__' + y.toString();\n\t}\n\n\t/**\n\t * Gets the Nood matching the given x y pair\n\t * Returns null if does not exists\n\t * @param x {number}\n\t * @param y {number}\n\t * @returns {Nood|null}\n\t */\n\tget(x, y) {\n\t\treturn this.oList[this.getKey(x, y)] || null;\n\t}\n\n\t/**\n\t * Remove a Nood from the list with the given coordinates\n\t * @param x {number}\n\t * @param y {number}\n\t */\n\tdel(x, y) {\n\t\tdelete this.oList[this.getKey(x, y)];\n\t}\n\n\t/**\n\t * Returns true if the liste is empty\n\t * @returns {boolean}\n\t */\n\tempty() {\n\t\treturn this.count() === 0;\n\t}\n};","const Astar = require('./Astar');\n\nmodule.exports = Astar;\n","/**\n * This class implements the bresenham algorithm\n * and extend its use for other purpose than drawing pixel lines\n * good to GIT\n */\nmodule.exports = class Bresenham {\n\t/**\n\t * This function will virtually draw points along a line\n\t * and will call back a plot function. \n\t * The line will start at x0, y0 and will end at x1, y1\n\t * Each time a points is \"drawn\" a callback is done \n\t * if the callback returns false, the line function will stop and return false\n\t * else the line function will return an array of plots\n\t * @param x0 starting point x\n\t * @param y0 starting point y\n\t * @param x1 ending point x\n\t * @param y1 ending point y\n\t * @param pCallback a plot function of type function(x, y, n) { return bool; }\n\t * avec x, y les coordonnées du point et n le numéro duj point\n\t * @returns {Boolean} false if the fonction has been canceled\n\t */\n\tstatic line(x0, y0, x1, y1, pCallback) {\n\t\tx0 |= 0;\n\t\ty0 |= 0;\n\t\tx1 |= 0;\n\t\ty1 |= 0;\n\t\tlet dx = Math.abs(x1 - x0);\n\t\tlet dy = Math.abs(y1 - y0);\n\t\tlet sx = (x0 < x1) ? 1 : -1;\n\t\tlet sy = (y0 < y1) ? 1 : -1;\n\t\tlet err = dx - dy;\n\t\tlet e2;\n\t\tlet n = 0;\n\t\twhile (true) {\n\t\t\tif (pCallback) {\n\t\t\t\tif (pCallback(x0, y0, n) === false) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x0 === x1 && y0 === y1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\te2 = err << 1;\n\t\t\tif (e2 > -dy) {\n\t\t\t\terr -= dy;\n\t\t\t\tx0 += sx;\n\t\t\t}\n\t\t\tif (e2 < dx) {\n\t\t\t\terr += dx;\n\t\t\t\ty0 += sy;\n\t\t\t}\n\t\t\t++n;\n\t\t}\n\t\treturn true;\n\t}\n};\n","/** Interface de controle des mobile \n * O876 Raycaster project\n * @class O876.Easing\n * @date 2013-03-04\n * @author Raphaël Marandet \n * Fait bouger un mobile de manière non-lineaire\n * Avec des coordonnée de dépat, d'arriver, et un temps donné\n * L'option lineaire est tout de même proposée.\n * good to GIT\n */\nmodule.exports = class Easing {\n\n\tconstructor() {\n\t\tthis.xStart = 0;\n\t\tthis.xEnd = 0;\n\t\tthis.x = 0;\n\t\tthis.nTime = 0;\n\t\tthis.iTime = 0;\n\t\tthis.fWeight = 1;\n\t\tthis.pFunction = null;\n\t}\n\n    /**\n\t * Will define de starting value\n     * @param x {number}\n     * @returns {O876.Easing}\n     */\n\tfrom(x) {\n\t\tthis.xStart = this.x = x;\n\t\treturn this;\n\t}\n\n    /**\n\t * Will define the ending value\n     * @param x {number}\n     * @returns {O876.Easing}\n     */\n\tto(x) {\n\t\tthis.xEnd = x;\n\t\treturn this;\n\t}\n\n    /**\n\t * Will define the duration of the transition\n     * @param t {number} arbitrary unit\n     * @returns {O876.Easing}\n     */\n\tduring(t) {\n\t\tthis.nTime = t;\n\t\tthis.iTime = 0;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Définition de la fonction d'Easing\n\t * @param xFunction {string|Function} fonction à choisir parmi :\n\t * linear : mouvement lineaire uniforme\n\t * smoothstep : accelération et déccelération douce\n\t * smoothstepX2 : accelération et déccelération moyenne\n\t * smoothstepX3 : accelération et déccelération brutale\n\t * squareAccel : vitesse 0 à T-0 puis uniquement accelération \n\t * squareDeccel : vitesse max à T-0 puis uniquement deccelération\n\t * cubeAccel : vitesse 0 à T-0 puis uniquement accelération brutale \n\t * cubeDeccel : vitesse max à T-0 puis uniquement deccelération brutale\n\t * sine : accelération et deccelération brutal, vitesse nulle à mi chemin\n\t * cosine : accelération et deccelération selon le cosinus, vitesse max à mi chemin\n\t * weightAverage : ... me rapelle plus \n\t */\n\tuse(xFunction) {\n\t\tswitch (typeof xFunction) {\n\t\t\tcase 'string':\n\t\t\t\tthis.pFunction = this['_' + xFunction].bind(this);\n\t\t\tbreak;\n\n\t\t\tcase 'function':\n\t\t\t\tthis.pFunction = xFunction;\n\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error('unknown function type');\n\t\t}\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Calcule les coordonnée pour le temps t\n\t * mets à jour les coordonnée x et y de l'objets\n\t * @param t {number} temps\n\t * si \"t\" est indéfini, utilise le timer interne \n\t */\n\tnext(t) {\n\t\tif (t === undefined) {\n\t\t\tt = ++this.iTime;\n\t\t} else {\n\t\t\tthis.iTime = t;\n\t\t}\n\t\tlet p = this.pFunction;\n\t\tif (typeof p !== 'function') {\n\t\t\tthrow new Error('easing function is invalid : ' + p);\n\t\t}\n\t\tlet v = p(t / this.nTime);\n\t\tthis.x = this.xEnd * v + (this.xStart * (1 - v));\n\t\treturn this;\n\t}\n\n\tval() {\n\t\treturn this.x;\n\t}\n\n\tover() {\n\t\treturn this.iTime >= this.nTime;\n\t}\n\n\t_linear(v) {\n\t\treturn v;\n\t}\n\t\n\t_smoothstep(v) {\n\t\treturn v * v * (3 - 2 * v);\n\t}\n\t\n\t_smoothstepX2(v) {\n\t\tv = v * v * (3 - 2 * v);\n\t\treturn v * v * (3 - 2 * v);\n\t}\n\t\n\t_smoothstepX3(v) {\n\t\tv = v * v * (3 - 2 * v);\n\t\tv = v * v * (3 - 2 * v);\n\t\treturn v * v * (3 - 2 * v);\n\t}\n\t\n\t_squareAccel(v) {\n\t\treturn v * v;\n\t}\n\t\n\t_squareDeccel(v) {\n\t\treturn 1 - (1 - v) * (1 - v);\n\t}\n\t\n\t_cubeAccel(v) {\n\t\treturn v * v * v;\n\t}\n\t\n\t_cubeDeccel(v) {\n\t\treturn 1 - (1 - v) * (1 - v) * (1 - v);\n\t}\n\t\n\t_cubeInOut(v) {\n\t\tif (v < 0.5) {\n\t\t\tv = 2 * v;\n\t\t\treturn v * v * v;\n\t\t} else {\n\t\t\tv = (1 - v) * 2;\n\t\t\treturn v * v * v;\n\t\t}\n\t}\n\t\n\t_sine(v) {\n\t\treturn Math.sin(v * Math.PI / 2);\n\t}\n\t\n\t_cosine(v) {\n\t\treturn 0.5 - Math.cos(-v * Math.PI) * 0.5;\n\t}\n\t\n\t_weightAverage(v) {\n\t\treturn ((v * (this.nTime - 1)) + this.fWeight) / this.nTime;\n\t}\n\t\n\t_quinticBezier(v) {\n\t\tlet ts = v * this.nTime;\n\t\tlet tc = ts * this.nTime;\n\t\treturn 4 * tc - 9 * ts + 6 * v;\n\t}\n};","const SpellBook = require('../SpellBook');\nconst Random = require('../Random');\nconst Rainbow = require('../Rainbow');\nconst Cache2D = require('../structures/Cache2D');\n\n\nclass Perlin {\n\n\tconstructor() {\n\t\tthis._size = 64;\n\t\tthis._width = 64;\n\t\tthis._height = 64;\n\t\tthis._octaves = 8;\n\t\tthis._interpolate = null;\n\t\tthis._rand = new Random();\n\t\tthis.interpolation('cosine');\n\t\tthis._cache = new Cache2D();\n\t\tthis._seed = 1;\n\t}\n\n\tseed(n) {\n\t\treturn SpellBook.prop(this, '_seed', n);\n\t}\n\t\n\tsize(n) {\n\t\tif (n === undefined) {\n\t\t\treturn this._size;\n\t\t} else {\n\t\t\tlet i = 10;\n\t\t\twhile (i > 0) {\n\t\t\t\tlet i2 = 1 << i;\n\t\t\t\tif (i2 === n) {\n\t\t\t\t\tthis._width = i2;\n\t\t\t\t\tthis._height = i2;\n\t\t\t\t\tthis._octaves = i;\n\t\t\t\t\tthis._size = n;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\t--i;\n\t\t\t}\n\t\t\tthrow new Error('size must be a power of 2 between 2 and 1024');\n\t\t}\n\t}\n\t\n\twidth() {\n\t\treturn this._width;\n\t}\n\n\theight(h) {\n\t\treturn this._height;\n\t}\n\t\n\toctaves(n) {\n\t\treturn this._octaves;\n\t}\n\n\t/**\n\t * Generate white noise on a matrix\n\t * @param w matrix width\n\t * @param h matrix height\n\t * @return {array}\n\t */\n\tgenerateWhiteNoise(w, h) {\n\t\tlet r, a = [], rand = this._rand;\n\t\tfor (let x, y = 0; y < h; ++y) {\n\t\t\tr = []; \n\t\t\tfor (x = 0; x < w; ++x) {\n\t\t\t\tr.push(rand.rand());\n\t\t\t}\n\t\t\ta.push(r);\n\t\t}\n\t\treturn a;\n\t}\n\n\t/**\n\t * Linear interpolation\n\t * @param x0 {number} minimum\n\t * @param x1 {number} maximum\n\t * @param alpha {number} value between 0 and 1\n\t * @return {number} float, interpolation result\n\t */\n\tstatic linearInterpolate(x0, x1, alpha) {\n\t\treturn x0 * (1 - alpha) + alpha * x1;\n\t}\n\n\t/**\n\t * Cosine Interpolation\n\t * @param x0 {number} minimum\n\t * @param x1 {number} maximum\n\t * @param alpha {number} value between 0 and 1\n\t * @return {number} float, interpolation result\n\t */\n\tstatic cosineInterpolate(x0, x1, mu) {\n\t\tlet mu2 = (1 - Math.cos(mu * Math.PI)) / 2;\n   \t\treturn x0 * (1 - mu2) + x1 * mu2;\n\t}\n\n\t/**\n\t * selects or define an interpolation function\n\t * @param f string | function the new interpolation function\n\t * f can be either a string ('cosine', 'linear') or a custom function\n\t */\n\tinterpolation(f) {\n\t\tswitch (typeof f) {\n\t\t\tcase 'string':\n\t\t\t\tif ((f + 'Interpolate') in Perlin) {\n\t\t\t\t\tthis._interpolate = Perlin[f + 'Interpolate'];\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error('only \"linear\" or \"cosine\" interpolation');\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t\t\n\t\t\tcase 'function':\n\t\t\t\tthis._interpolate = f;\n\t\t\t\treturn this;\n\t\t\t\t\n\t\t\tcase 'undefined':\n\t\t\t\treturn this._interpolate;\n\t\t}\n\t\treturn this;\n\t}\n\n\tstatic generateSmoothNoise(aBaseNoise, nOctave) {\n\t\tlet w = aBaseNoise.length;\n\t\tlet h = aBaseNoise[0].length;\n\t\tlet aSmoothNoise = [];\n\t\tlet r;\n\t\tlet nSamplePeriod = 1 << nOctave;\n\t\tlet fSampleFreq = 1 / nSamplePeriod;\n\t\tlet xs = [], ys = [];\n\t\tlet hBlend, vBlend, fTop, fBottom;\n\t\tlet interpolate = Perlin.cosineInterpolate;\n\t\tfor (let x, y = 0; y < h; ++y) {\n      \t\tys[0] = (y / nSamplePeriod | 0) * nSamplePeriod;\n      \t\tys[1] = (ys[0] + nSamplePeriod) % h;\n      \t\thBlend = (y - ys[0]) * fSampleFreq;\n      \t\tr = [];\n\t\t\tlet bny0 = aBaseNoise[ys[0]];\n\t\t\tlet bny1 = aBaseNoise[ys[1]];\n      \t\tfor (x = 0; x < w; ++ x) {\n       \t\t\txs[0] = (x / nSamplePeriod | 0) * nSamplePeriod;\n      \t\t\txs[1] = (xs[0] + nSamplePeriod) % w;\n      \t\t\tvBlend = (x - xs[0]) * fSampleFreq;\n\n      \t\t\tfTop = interpolate(bny0[xs[0]], bny1[xs[0]], hBlend);\n      \t\t\tfBottom = interpolate(bny0[xs[1]], bny1[xs[1]], hBlend);\n     \t\t\t\n     \t\t\tr.push(interpolate(fTop, fBottom, vBlend));\n      \t\t}\n\n      \t\taSmoothNoise.push(r);\n\t\t}\n\t\treturn aSmoothNoise;\n\t}\n\n\tstatic generatePerlinNoise(aBaseNoise, nOctaveCount) {\n\t\tlet w = aBaseNoise.length;\n\t\tlet h = aBaseNoise[0].length;\n\t\tlet aSmoothNoise = [];\n\t\tlet fPersist = 0.5;\n\n\t\tfor (let i = 0; i < nOctaveCount; ++i) {\n\t\t\taSmoothNoise.push(Perlin.generateSmoothNoise(aBaseNoise, i));\n\t\t}\n\n\t\tlet aPerlinNoise = [];\n\t\tlet fAmplitude = 1;\n\t\tlet fTotalAmp = 0;\n\t\tlet x, y, r;\n\n\t\tfor (y = 0; y < h; ++y) {\n\t\t\tr = [];\n\t\t\tfor (x = 0; x < w; ++x) {\n\t\t\t\tr.push(0);\n\t\t\t}\n\t\t\taPerlinNoise.push(r);\n\t\t}\n\n\t\tfor (let iOctave = nOctaveCount - 1; iOctave >= 0; --iOctave) {\n\t\t\tfAmplitude *= fPersist;\n\t\t\tfTotalAmp += fAmplitude;\n\t\t\tlet sno = aSmoothNoise[iOctave];\n\n\t\t\tfor (y = 0; y < h; ++y) {\n\t\t\t\tlet snoy = sno[y];\n\t\t\t\tlet pny = aPerlinNoise[y];\n\t\t\t\tfor (x = 0; x < w; ++x) {\n\t\t\t\t\tpny[x] += snoy[x] * fAmplitude;\n\t\t\t\t}\n\t\t\t} \n\t\t}\n\t\tfor (y = 0; y < h; ++y) {\n\t\t\tlet pny = aPerlinNoise[y];\n\t\t\tfor (x = 0; x < w; ++x) {\n\t\t\t\tpny[x] /= fTotalAmp;\n\t\t\t}\n\t\t}\n\t\treturn aPerlinNoise;\n\t}\n\n\n\tstatic hash (a) {\n\t\tif (a < 0) {\n\t\t\tlet b = 0, h = Perlin.hash(-a);\n\t\t\twhile (h) {\n\t\t\t\tb = (b << 4) | h & 15;\n\t\t\t\th >>= 4;\n\t\t\t}\n\t\t\treturn Math.abs(b);\n\t\t}\n\t    a = (a ^ 61) ^ (a >> 16);\n\t    a = a + (a << 3);\n\t    a = a ^ (a >> 4);\n\t    a = a * 0x27d4eb2d;\n\t    a = a ^ (a >> 15);\n    \treturn a;\n    }\n\n\t/** \n\t * Calcule le hash d'une région\n\t * Permet de choisir une graine aléatoire\n\t * et de raccorder seamlessly les région adjacente\n\t */\n\tstatic getPointHash(x, y) {\n\t\tlet xh = Perlin.hash(x).toString().split('');\n\t\tlet yh = Perlin.hash(y).toString().split('');\n\t\tlet s = xh.shift() + yh.shift() + '.';\n\t\twhile (xh.length || yh.length) {\n\t\t\tif (xh.length) {\n\t\t\t\ts += xh.shift();\n\t\t\t}\n\t\t\tif (yh.length) {\n\t\t\t\ts += yh.shift();\n\t\t\t}\n\t\t}\n\t\treturn parseFloat(s);\n\t}\n\t\n\tgenerate(x, y, callbacks) {\n\t\tif (x >= Number.MAX_SAFE_INTEGER || x <= -Number.MAX_SAFE_INTEGER || y >= Number.MAX_SAFE_INTEGER || y <= -Number.MAX_SAFE_INTEGER) {\n\t\t\tthrow new Error('trying to generate x:' + x + ' - y:' + y + ' - maximum safe integer is ' + Number.MAX_SAFE_INTEGER + ' !');\n\t\t}\n\t\tcallbacks = callbacks || {};\n\t\tlet perlin = 'perlin' in callbacks ? callbacks.perlin : null;\n\t\tlet noise = 'noise' in callbacks ? callbacks.noise : null;\n\t\tlet cached = this._cache.getPayload(x, y);\n\t\tif (cached) {\n\t\t\treturn cached;\n\t\t}\n\n\t\tconst RAND = this._rand;\n\t\t\n\t\tconst gwn = (xg, yg) => {\n\t\t\tlet nSeed = Perlin.getPointHash(xg, yg);\n\t\t\tRAND.seed(nSeed + this._seed);\n\t\t\tlet aNoise = this.generateWhiteNoise(this.width(), this.height());\n\t\t\tif (noise) {\n\t\t\t\taNoise = noise(xg, yg, aNoise);\n\t\t\t}\n\t\t\treturn aNoise;\n\t\t};\n\n\t\tconst merge33 = a33 => {\n\t\t\tlet h = this.height();\n\t\t\tlet a = [];\n\t\t\tfor (let y, ya = 0; ya < 3; ++ya) {\n\t\t\t\tlet a33ya = a33[ya];\n\t\t\t\tlet a33ya0 = a33ya[0];\n\t\t\t\tlet a33ya1 = a33ya[1];\n\t\t\t\tlet a33ya2 = a33ya[2];\n\t\t\t\tfor (y = 0; y < h; ++y) {\n\t\t\t\t\ta.push(a33ya0[y].concat(a33ya1[y], a33ya2[y]));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn a;\n\t\t};\n\n\t\tconst extract33 = a => {\n\t\t\tlet w = this.width();\n\t\t\tlet h = this.height();\n\t\t\treturn a.slice(h, h << 1).map(function(r) { return r.slice(w, w << 1); });\n\t\t};\n\n\t\tlet a0 = [\n\t\t\t[gwn(x - 1, y - 1), gwn(x, y - 1), gwn(x + 1, y - 1)],\n\t\t\t[gwn(x - 1, y), gwn(x, y), gwn(x + 1, y)],\n\t\t\t[gwn(x - 1, y + 1), gwn(x, y + 1), gwn(x + 1, y + 1)]\n\t\t];\n\n\t\tlet a1 = merge33(a0);\n\t\tlet a2 = Perlin.generatePerlinNoise(a1, this._octaves);\n\t\tlet a3 = extract33(a2);\n\t\tif (perlin) {\n\t\t\ta3 = perlin(x, y, a3);\n\t\t}\n\t\tthis._cache.push(x, y, a3);\n\t\treturn a3;\n\t}\n\n\t/**\n\t * Applique une palette au bruit généré\n\t * @param aNoise {Array} an array produced by generate()\n\t * @param aPalette {array}\n\t */\n\tstatic colorize(aNoise, aPalette) {\n\t\tlet pl = aPalette.length;\n\t\tlet data = [];\n\t\taNoise.forEach(r => r.forEach(x => {\n\t\t\tlet nColor = Math.min(pl - 1, x * pl | 0);\n\t\t\tdata.push(aPalette[nColor])\n\t\t}));\n\t\treturn data;\n\t}\n\n\n}\n\nmodule.exports = Perlin;","/**\n * @class SquareSpiral\n * This simple class builds a squared shape spiral\n * and reports all cells into an ordered list of Point\n * starting from the spiral center.\n */\n\nmodule.exports = class SquareSpiral {\n\t/**\n\t * Renvoie la largeur d'un carré de snail selon le niveau\n\t * @param nLevel niveau\n\t * @return int nombre d'élément sur le coté\n\t */\n\tstatic _getLevelSquareWidth(nLevel) {\n\t\treturn nLevel * 2 + 1;\n\t}\n\t\n\t/**\n\t * Renvoie le nombre d'éléments qu'il y a dans un niveau\n\t * @param nLevel niveau\n\t * @return int nombre d'élément\n\t */\n\tstatic _getLevelItemCount(nLevel) {\n\t\tlet w = SquareSpiral._getLevelSquareWidth(nLevel);\n\t\treturn 4 * w - 4;\n\t}\n\t\n\t/**\n\t * Renvoie le niveau auquel appartient ce secteur\n\t * le niveau 0 correspond au point 0, 0\n\t */\n\tstatic _getLevel(x, y) {\n\t\tx = Math.abs(x);\n\t\ty = Math.abs(y);\n\t\treturn Math.max(x, y);\n\t}\n\t\n\t/**\n\t * Renvoie tous les secteurs de niveau spécifié\n\t */\n\tstatic build(nLevelMin, nLevelMax) {\n\t\tif (nLevelMax === undefined) {\n\t\t\tnLevelMax = nLevelMin;\n\t\t}\n\t\tif (nLevelMin > nLevelMax) {\n\t\t\tthrow new Error('levelMin must be lower or equal levelMax');\n\t\t}\n\t\tif (nLevelMin < 0) {\n\t\t\treturn [];\n\t\t}\n\t\tlet aSectors = [];\n\t\tlet n, x, y;\n\t\tfor (y = -nLevelMax; y <= nLevelMax; ++y) {\n\t\t\tfor (x = -nLevelMax; x <= nLevelMax; ++x) {\n\t\t\t\tn = SquareSpiral._getLevel(x, y);\n\t\t\t\tif (n >= nLevelMin && n <= nLevelMax) {\n\t\t\t\t\taSectors.push({x: x, y: y});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn aSectors;\n\t}\n};\n","/**\n * A partir d'une liste de mots, cette classe peut générer de nouveaux mots ressemblant à ceux de la liste\n */\nconst Random = require('../Random');\n\nclass UnivGeneList {\n\n    constructor() {\n        this._random = new Random();\n        this._registries = {};\n        this._exclusions = [];\n    }\n\n    /**\n     * Ajoute une lettre à la liste des lettres du pattern du registre spécifié\n     * @param oRegistry\n     * @param pattern\n     * @param letter\n     */\n    pushLetter(oRegistry, pattern, letter) {\n        if (!(pattern in oRegistry)) {\n            oRegistry[pattern] = letter;\n        } else {\n            oRegistry[pattern] += letter;\n        }\n    }\n\n    /**\n     * Chargement d'une liste et indexation\n     * @param aList {string[]}\n     * @param n {number}\n     * @return {*}\n     */\n    indexListProb(aList, n) {\n        const ALPHA = ('abcdefghijklmnopqrstuvwxyz').split('');\n        let oRegistry = {};\n        aList.forEach(word => {\n            word = word.replace(/[^a-z]+/g, '');\n            if (word.length > n) {\n                for (let i = 0; i < word.length - n; ++i) {\n                    let letter = word.charAt(i + n);\n                    let pattern = word.substr(i, n);\n                    this.pushLetter(oRegistry, pattern, letter);\n                }\n            }\n        });\n        return oRegistry;\n    }\n\n    indexListInitial(aList, n) {\n        return aList.map(word => word.substr(0, n))\n    }\n\n    indexListFinal(aList, n) {\n        let oRegistry = {};\n        aList.forEach(word => {\n            this.pushLetter(oRegistry, word.substr(-n - 1, n), word.substr(-1));\n        });\n        return oRegistry;\n    }\n\n    indexList(aList, nPatternLength) {\n        if (aList.length === 0) {\n            throw new Error('nothing to index, the list is empty');\n        }\n        aList = aList.filter(word => !!word);\n        this._registries = {\n            initial: this.indexListInitial(aList, nPatternLength),\n            prob: this.indexListProb(aList, nPatternLength),\n            final: this.indexListFinal(aList, nPatternLength)\n        };\n    }\n\n    hasBeenIndexed() {\n        let regInitial = this._registries.initial;\n        let regProb = this._registries.prob;\n        let regFinal = this._registries.final;\n        return regInitial && regProb && regFinal;\n    }\n\n    exclude(aList) {\n        this._exclusions = this._exclusions.concat(aList);\n    }\n\n    generate(nLength, nPatternLength) {\n        let random = this._random;\n        let regInitial = this._registries.initial;\n        let regProb = this._registries.prob;\n        let regFinal = this._registries.final;\n        if (!this.hasBeenIndexed()) {\n            throw new Error('you must initialize registries by indexing a list');\n        }\n        let sPattern = this._random.randPick(regInitial);\n        let sResult = sPattern;\n        while (sResult.length < (nLength - 1)) {\n            let p = regProb[sPattern] ? random.randPick(regProb[sPattern]) : '';\n            if (p) {\n                sResult += p;\n                sPattern = sResult.substr(-nPatternLength);\n            } else {\n                return '';\n            }\n        }\n        if (regFinal[sPattern]) {\n            sResult += random.randPick(regFinal[sPattern]);\n        } else if (regProb[sPattern]) {\n            sResult += random.randPick(regProb[sPattern]);\n        }\n        if (this._exclusions.includes(sResult)) {\n            return '';\n        }\n        return sResult;\n    }\n}\n\nmodule.exports = UnivGeneList;","const Bresenham = require('./Bresenham');\nconst Easing = require('./Easing');\nconst Perlin = require('./Perlin');\nconst SquareSpiral = require('./SquareSpiral');\nconst Astar = require('./Astar');\nconst UnivGeneList = require('./UnivGeneList');\n\nmodule.exports = {\n    Bresenham,\n    Easing,\n    Perlin,\n    SquareSpiral,\n    Astar,\n    UnivGeneList\n};\n","/**\n * @class Collider\n * The collider computes collision between sprites.\n * Sprites are positionned inside the collider grid, according to their position\n * Each sprites is tested against all other sprite in the surroundiing cells.\n */\n\nconst Vector = require('../geometry/Vector');\nconst Grid = require('../structures/Grid');\nconst Sector = require('./Sector');\nconst SB = require('../SpellBook');\n\nmodule.exports = class Collider {\n\tconstructor() {\n        this._origin = new Vector(); // vector origine du layer\n        this._grid = new Grid();\n        this._grid.on('rebuild', function(data) {\n            let oSector = new Sector();\n            oSector.x = data.x;\n            oSector.y = data.y;\n            data.cell = oSector;\n        });\n        this._cellWidth = 0;\n        this._cellHeight = 0;\n\t}\n\n    cellWidth(w) {\n        return SB.prop(this, '_cellWidth', w);\n    }\n\n    cellHeight(h) {\n        return SB.prop(this, '_cellHeight', h);\n    }\n\n    width(w) {\n        if (w === undefined) {\n            return this._grid.width();\n        } else {\n            this._grid.width(w);\n            return this;\n        }\n    }\n\n    height(h) {\n        if (h === undefined) {\n            return this._grid.height();\n        } else {\n            this._grid.height(h);\n            return this;\n        }\n    }\n\n\t/**\n\t * Return the sector corresponding to the given coordinates\n     * if the parameters are number, the real sector indices are used (0, 1, 2...)\n\t * if the parameter is a Vector, its components are int-divided by cell size before application\n\t * @param x {number} position x\n\t * @param y {number} position y\n\t * @return {*}\n\t */\n\tsector(x, y) {\n\t\tif (y === undefined) {\n\t\t\treturn this._grid.cell(x.x / this._cellWidth | 0, x.y / this._cellHeight | 0);\n\t\t} else {\n\t\t\treturn this._grid.cell(x, y);\n\t\t}\n\t}\n\n\t/**\n\t * Registers an object in the sector it belongs\n\t * Unregisters the objet in all other sector\n\t * @param oDummy {Dummy}\n\t */\n\ttrack(oDummy) {\n\t\tlet oOldSector = oDummy.colliderSector;\n\t\tlet v = oDummy.position().sub(this._origin);\n\t\tlet s = oDummy.dead() ? null : this.sector(v);\n\t\tif (s && oOldSector && s === oOldSector) {\n\t\t\treturn;\n\t\t}\n\t\tif (oOldSector) {\n\t\t\toOldSector.remove(oDummy);\n\t\t}\n\t\tif (s) {\n\t\t\ts.add(oDummy);\n\t\t}\n\t\toDummy.colliderSector = s;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Effectue tous les test de collision entre un objet et tous les autres objets\n\t * contenus dans les secteur adjacent a celui de l'objet\n\t * @param oDummy {Dummy}\n\t * @return {Dummy[]} liste d'objet collisionnant\n\t */\n\tcollides(oDummy) {\n\t\tlet a = [];\n\t\tlet oSector = this.sector(oDummy.position().sub(this._origin));\n\t\tif (!oSector) {\n\t\t\treturn a;\n\t\t}\n\t\tlet x = oSector.x;\n\t\tlet y = oSector.y;\n\t\tlet xMin = Math.max(0, x - 1);\n\t\tlet yMin = Math.max(0, y - 1);\n\t\tlet xMax = Math.min(this.width() - 1, x + 1);\n\t\tlet yMax = Math.min(this.height() - 1, y + 1);\n\t\tlet ix, iy;\n\t\tfor (iy = yMin; iy <= yMax; ++iy) {\n\t\t\tfor (ix = xMin; ix <= xMax; ++ix) {\n\t\t\t\ta = a.concat(this.sector(ix, iy).collides(oDummy));\n\t\t\t}\n\t\t}\n\t\treturn a;\n\t}\n};","/**\n * @class Mobile\n * This class manages a mobile object.\n */\nconst sb = require('../SpellBook');\nconst geometry = require('../geometry');\nconst Helper = geometry.Helper;\nconst Vector = geometry.Vector;\n\nmodule.exports = class Dummy {\n\tconstructor() {\n\t\tthis._position = new Vector();\n\t\tthis._dead = false; // les mobile noté \"dead\" doivent être retiré du jeu\n\t\tthis._radius = 0;\n\t\tthis._tangibility = {\n\t\t\tself: 1,\n\t\t\thitmask: 1\n\t\t};\n\t}\n\n\t/**\n\t * Renvoie true si le masque-tangibilité de ce dummy correspond au type-tangibilité du dummy spécifié\n\t * @param dummy\n\t */\n\ttangibleWith(dummy) {\n\t\treturn (dummy._tangibility.self & this._tangibility.hitmask) !== 0;\n\t}\n\n    /**\n\t * Setter/getter du rayon du mobile\n     * @param r\n     * @returns {*}\n     */\n\tradius(r) {\n        return sb.prop(this, '_radius', r);\n\t}\n\n    /**\n\t * Setter/Getter de la position du mobile\n     * @param p\n     * @returns {*}\n     */\n\tposition(p) {\n        return sb.prop(this, '_position', p);\n\t}\n\n    /**\n     * Setter/Getter of dead flag...\n     * dead Mobile must be removed from game\n     * @param b {boolean}\n     * @return {boolean|Mobile}\n     */\n    dead(b) {\n        return sb.prop(this, '_dead', b);\n    }\n\n    /**\n\t * Calcule la distance entre le mobile et un autre mobile\n     * @param oOther {Mobile}\n     * @returns {*|float|number}\n     */\n\tdistanceTo(oOther) {\n\t\tlet p1 = this.position();\n\t\tlet p2 = oOther.position();\n        return Helper.distance(p1.x, p1.y, p2.x, p2.y);\n\t}\n\n    /**\n\t * Renvoi l'angle entre les deux mobile (this et oOther) et l'axe X\n     * @param oOther\n     * @returns {number}\n     */\n\tangleTo(oOther) {\n        let p1 = this.position();\n        let p2 = oOther.position();\n        return Helper.angle(p1.x, p1.y, p2.x, p2.y);\n\t}\n\n    /**\n\t * renvoie true si les deux mobile se collisionne.\n     * @param oOther {Dummy}\n     * @returns {boolean}\n     */\n\thits(oOther) {\n\t\treturn this.tangibleWith(oOther) && this.distanceTo(oOther) < this._radius + oOther.radius();\n\t}\n};","/**\n * Classe enregistrant les mobile qui s'aventure dans un secteur particulier\n * du monde. LEs Mobile d'un même secteurs sont testé entre eux pour savoir\n * Qui entre en collision avec qui. */\nmodule.exports = class Sector {\n    constructor() {\n        this._objects = [];\n        this.x = -1;\n        this.y = -1;\n    }\n\n    objects() {\n        return this._objects;\n    }\n\n    add(oObject) {\n        this._objects.push(oObject);\n    }\n\n    remove(oObject) {\n        let objects = this._objects;\n        let n = objects.indexOf(oObject);\n        if (n >= 0) {\n            objects.splice(n, 1);\n        }\n    }\n\n    /**\n     * Renvoie le nombre d'objet enregistrer dans le secteur\n     * @return int\n     */\n    count() {\n        return this._objects.length;\n    }\n\n    /** Renvoie l'objet désigné par son rang */\n    get(i) {\n        return this._objects[i] || null;\n    }\n\n    /** Renvoie les objets qui collisione avec l'objet spécifié */\n    collides(oObject) {\n        return this._objects\n            .filter(function(o) {\n                return o !== oObject &&\n                    oObject.hits(o)\n            });\n    }\n};\n\n\n","const Dummy = require('./Dummy');\nconst Collider = require('./Collider');\nconst Sector = require('./Sector');\n\nmodule.exports = {\n    Dummy,\n    Collider,\n    Sector\n};","/**\n * Created by ralphy on 07/09/17.\n */\n\n/**\n * A simple helper class\n */\nmodule.exports = class Helper {\n\t/**\n\t * Distance between 2 points\n\t * @param x1 {Number} point 1 coordinates\n\t * @param y1 {Number}\n\t * @param x2 {Number} point 2 coordinates\n\t * @param y2 {Number}\n\t * @return {number} distance\n\t */\n\tstatic distance(x1, y1, x2, y2) {\n\t\tlet dx = x1 - x2;\n\t\tlet dy = y1 - y2;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t}\n\n    /**\n\t * Renvoie true si le point est dans le rectangle\n     * @param x {number} coordonnée du point\n     * @param y {number} coordonnée du point\n     * @param xr {number} coordonnée du rect\n     * @param yr {number} coordonnée du rect\n     * @param wr {number} largeur du rect\n     * @param hr {number} hauteur du rect\n     * @return {boolean}\n     */\n\tstatic pointInRect(x, y, xr, yr, wr, hr) {\n\t\treturn x >= xr && y >= yr && x < xr + wr && y < yr + hr;\n\t}\n\n\tstatic rectInRect(ax, ay, aw, ah, bx, by, bw, bh) {\n        let ax2 = ax + aw - 1;\n        let ay2 = ay + ah - 1;\n        let bx2 = bx + bw - 1;\n        let by2 = by + bh - 1;\n        return ax < bx2 && ax2 > bx &&\n            ay > by2 && ay2 < by;\n    }\n\n    /**\n\t * Renvoie l'ange que fait la doite x1, y1, x2, y2\n\t * avec l'axe des X+\n     * @param x1 {number}\n     * @param y1 {number}\n     * @param x2 {number}\n     * @param y2 {number}\n\t * @return {number}\n     */\n\tstatic angle(x1, y1, x2, y2) {\n\t\treturn Math.atan2(y2 - y1, x2 - x1);\n\t}\n\n\t/**\n\t * A partir d'un angle et d'une norme, calcule deux composant d'un référentiel rectangulaire\n\t * @param angle\n\t * @param norm\n\t */\n\tstatic polar2rect(angle, norm) {\n\t\treturn {dx: norm * Math.cos(angle), dy: norm * Math.sin(angle)};\n\t}\n};","/**\n * Created by ralphy on 04/09/17.\n */\n\nconst Helper = require('./Helper');\n\nmodule.exports = class Point {\n\tconstructor(x, y) {\n\t\tif (typeof x === 'object' && ('x' in x) && ('y' in x)) {\n\t\t\tthis.x = x.x;\n\t\t\tthis.y = x.y;\n\t\t} else {\n            this.x = x;\n            this.y = y;\n\t\t}\n\t}\n\n\t/**\n\t * return the distance between this point and the given point\n\t * @param p {Point}\n\t * @return {number}\n\t */\n\tdistance(p) {\n\t\treturn Helper.distance(p.x, p.y, this.x, this.y);\n\t}\n};","/**\n * Created by ralphy on 04/09/17.\n *\n * @class Vector\n * @property {number} x\n * @property {number} y\n */\n\nconst Helper = require('./Helper.js');\n\nmodule.exports = class Vector {\n\t/**\n\t * The constructor accepts one two parameters\n\t * If one parameter is given, the constructor will consider it as\n\t * Vector and will build this vector accordingly.\n\t * If two parameters are given (both numbers), the constructor will initialize the x and y\n\t * components with these numbers.\n\t * if no parameters are given : the vector will be ZERO\n\t * @param (x) {Vector|number}\n\t * @param (y) {number}\n\t */\n\tconstructor(x, y) {\n\t\tif (x instanceof Vector) {\n\t\t\tthis.x = x.x;\n\t\t\tthis.y = x.y;\n\t\t} else {\n\t\t\tthis.x = x || 0;\n\t\t\tthis.y = y || 0;\n\t\t}\n\t}\n\n    /**\n\t * Mutable !\n\t * Modifie x et y\n     * @param x\n     * @param y\n     */\n\tset(x, y) {\n\t\tif (x instanceof Vector) {\n\t\t\treturn this.set(x.x, x.y);\n\t\t}\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Immutable !\n\t * returns a new Vector which is the sum of this instance + the given argument\n\t * @param v {Vector}\n\t * @returns {Vector}\n\t */\n\tadd(v) {\n\t\treturn new Vector(v.x + this.x, v.y + this.y);\n\t}\n\n\t/**\n\t * Immutable !\n\t * returns a new Vector which is the diffrence of this instance and the given argument\n\t * @param v\n\t */\n\tsub(v) {\n\t\treturn new Vector(this.x - v.x, this.y - v.y);\n\t}\n\n\t/**\n\t * Immutable !\n\t * returns a scalar product\n\t * multiplies the vector components by a given value -(vector or number)\n\t * @param f {Vector|number}\n\t * @returns {Vector|number}\n\t */\n\tmul(f) {\n\t\tif (f instanceof Vector) {\n\t\t\treturn this.x * f.x + this.y * f.y;\n\t\t} else if (typeof f === 'number') {\n\t\t\treturn new Vector(this.x * f, this.y * f);\n\t\t} else {\n\t\t\tthrow new Error('vector product accepts only vectors or number as parameter');\n\t\t}\n\t}\n\n\t/**\n\t * return the vector distance\n\t * @return {number}\n\t */\n\tdistance() {\n\t\treturn Helper.distance(0, 0, this.x, this.y);\n\t}\n\n\t/**\n\t * returns a normalized version of this vector\n\t * @return {Vector}\n\t */\n\tnormalize() {\n\t\treturn this.mul(1 / this.distance());\n\t}\n\n\t/**\n\t * returns a zero vector\n\t * @returns {Vector}\n\t */\n\tstatic zero() {\n\t\treturn new Vector(0, 0);\n\t}\n\n    /**\n\t * Mutable\n\t * Addition mutable des composante du vecteur\n     * @param v {Vector}\n     */\n\ttranslate(v) {\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\treturn this;\n\t}\n\n    /**\n     * Mutable\n     * Multiplication mutable des composante du vecteur\n     * @param f {number}\n     */\n\tscale(f) {\n\t\tthis.x *= f;\n\t\tthis.y *= f;\n\t\treturn this;\n\t}\n\n    /**\n\t * Renvoie l'angle entre le vecteur et l'axe X\n\t * si le vecteur est dans la direction x+ alors l'angle = 0\n     */\n\tangle() {\n\t\treturn Helper.angle(0, 0, this.x, this.y);\n\t}\n\n\ttoString() {\n\t\treturn [this.x, this.y].map(n => n.toString()).join(':');\n\t}\n\n\tfromPolar(a, s) {\n\t\tlet v = Helper.polar2rect(a, s);\n\t\tthis.set(v.dx, v.dy);\n\t\treturn this;\n\t}\n};","const Vector = require('./Vector');\nconst sb =  require('../SpellBook');\n\nclass View {\n\tconstructor() {\n\t\tthis._offset = new Vector();\n\t\tthis._position = new Vector();\n\t\tthis._width = 0;\n\t\tthis._height = 0;\n\t}\n\n\toffset(v) {\n\t\treturn sb.prop(this, '_offset', v);\n\t}\n\n\tposition(v) {\n\t\treturn sb.prop(this, '_position', v);\n\t}\n\n\twidth(n) {\n\t\treturn sb.prop(this, '_width', n);\n\t}\n\n\theight(n) {\n\t\treturn sb.prop(this, '_height', n);\n\t}\n\n\tcenter() {\n\t\tthis.offset(new Vector(this.width() >> 1, this.height() >> 1));\n\t}\n\n\tpoints() {\n\t\tlet p0 = this._position.sub(this._offset);\n\t\tlet p1 = p0.add(new Vector(this._width, this._height));\n\t\treturn [p0, p1];\n\t}\n}","const Helper = require('./Helper');\nconst Point = require('./Point');\nconst Vector = require('./Vector');\nconst View = require('../geometry/View');\n\nmodule.exports = {\n\tHelper,\n\tPoint,\n\tVector,\n\tView\n};","const geometry = require('./geometry');\nconst algorithms = require('./algorithms');\nconst SpellBook = require('./SpellBook');\nconst Random = require('./Random');\nconst Rainbow = require('./Rainbow');\nconst Emitter = require('./Emitter');\nconst collider = require('./collider');\nconst structures = require('./structures');\nconst Cache2D = require('./structures/Cache2D');\n\nmodule.exports = {\n\n\t// namespaces\n\talgorithms,\n\tcollider,\n\tgeometry,\n\tstructures,\n\n\t// classes\n\tSpellBook,\n\tRandom,\n\tRainbow,\n\tEmitter\n};","/**\n * Permet de mettre en cache des information indéxées par une coordonnées 2D\n */\nclass Cache2D {\n\tconstructor(d = null) {\n\t\tlet size = 64;\n\t\tif (d) {\n\t\t\tsize = d.size || size;\n\t\t}\n\t\tthis._cache = [];\n\t\tthis._cacheSize = size;\n\t}\n\n\tgetMetaData(x, y) {\n\t\treturn this._cache.find(o => o.x === x && o.y === y);\n\t}\n\n\tgetPayload(x, y) {\n\t\tlet o = this.getMetaData(x, y);\n\t\tif (o) {\n\t\t\treturn o.payload;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpush(x, y, payload) {\n\t\tlet c = this._cache;\n\t\tif (!this.getMetaData(x, y)) {\n\t\t\tc.push({\n\t\t\t\tx, y, payload\n\t\t\t});\n\t\t}\n\t\tlet aDelete = [];\n\t\twhile (c.length > this._cacheSize) {\n\t\t\taDelete.push(c.shift());\n\t\t}\n\t\treturn aDelete;\n\t}\n}\n\nmodule.exports = Cache2D;","/**\n * @class Grid\n * This class is a generic grid containing anything\n * When new items are needed (when the grid changes size and gets larger)\n * an event is fired : \"rebuild\" which can be handled to construct cell content.\n */\nconst sb = require('../SpellBook');\nconst Emitter = require('../Emitter');\n\nmodule.exports = class Grid {\n\tconstructor() {\n        this._cells = null;\n        this._width = 0;\n        this._height = 0;\n        this.emitter = new Emitter();\n\t}\n\n    on() { this.emitter.on(...arguments); return this; }\n    off() { this.emitter.off(...arguments); return this; }\n    one() { this.emitter.one(...arguments); return this; }\n    trigger() { this.emitter.trigger(...arguments); return this; }\n\n\n    /**\n\t * Setter/Getter for a dimensionnal array of cells, wich represents the grid content.\n     * @param (x) {array}\n     * @return {Grid|array}\n     */\n\tcells(x) {\n        if (x !== undefined) {\n            this._height = x.length;\n            if (this._height) {\n            \tthis._width = x[0].length;\n\t\t\t} else {\n                this._width = 0;\n\t\t\t}\n        }\n\t\treturn sb.prop(this, '_cells', x);\n\t}\n\n    /**\n     * Setter/Getter for the grid width.\n\t * setting a new width will rebuild the grid\n     * @param (w) {number}\n     * @return {Grid|number}\n     */\n    width(w) {\n\t\tif (w !== undefined) {\n\t\t\tthis._rebuild(w, this._height);\n\t\t}\n        return sb.prop(this, '_width', w);\n    }\n\n    /**\n     * Setter/Getter for the grid height.\n     * setting a new height will rebuild the grid\n     * @param (h) {number}\n     * @return {Grid|number}\n     */\n    height(h) {\n        if (h !== undefined) {\n            this._rebuild(this._width, h);\n        }\n        return sb.prop(this, '_height', h);\n    }\n\n    /**\n\t * Rebuilds the grid according to the given dimensions\n\t * @param w {number}\n\t * @param h {number}\n\t * @private\n\t * @return {array}\n\t */\n\t_rebuild(w, h) {\n\t\tlet g = [];\n\t\tlet x, y, aRow, data;\n\t\tfor (y = 0; y < h; y++) {\n\t\t\taRow = [];\n\t\t\tfor (x = 0; x < w; x++) {\n\t\t\t\tdata = {x: x, y: y, width: w, height: h, cell: null};\n\t\t\t\tthis.trigger('rebuild', data);\n\t\t\t\taRow.push(data.cell);\n\t\t\t}\n\t\t\tg.push(aRow);\n\t\t}\n\t\tthis._width = w;\n\t\tthis._height = h;\n\t\tthis.cells(g);\n\t}\n\n    /**\n\t * Sets/Gets a cell value given its coordinates\n     * @param x {number}\n     * @param y {number}\n     * @param (v) {*}\n     * @return {*}\n     */\n\tcell(x, y, v) {\n\t\tif (v === undefined) {\n\t\t\tif (y >= 0 && y >= 0 && y < this._height && x < this._width) {\n\t\t\t\treturn this._cells[y][x];\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} else {\n\t\t\tif (y >= 0 && y >= 0 && y < this._height && x < this._width) {\n\t\t\t\tthis._cells[y][x] = v;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t}\n};\n","/**\n * @class TileLayer\n * TileLayer est capable de gérer une infinité de portion de terrain\n * Seules les portions a l'interieur de la zone de vue sont affichée.\n * lors de la phase de rendu, le WorldPlayer génère des évènements\n * indiquant les coordonnées des portions qu'il souhaite afficher\n * C'est à l'appli, en réponse à ces évènements, de fournir les portions\n * sous forme d'un canvas ou d'une image.\n *\n *\n *\n */\nconst View = require('../geometry/View');\nconst sb = require('../SpellBook');\n\nclass TileLayer {\n\tconstructor() {\n\t\tthis._view = new View();\n\t\tthis._zones = {};\n\t\tthis._zoneWidth = 0;\n\t\tthis._zoneHeight = 0;\n\t\tthis._zones = null;\n\t\tthis._moreZones = false;  // a true ce flag permet de gérer également les zone\n\t\t// adjacentes aux zones qui sont partiellement visible dans la vue\n\t\t// utile pour permettre au système d'eventuellement précharger les zones\n\t\t// si la conception des zone dépend d'un résultat ajax ou d'un Worker.\n\t}\n\n\t/**\n\t * Setter / getter d'un objet Fairy.View\n\t * Cet objet permet de définir la fenetre de vue du world layer\n\t * @param v {View}\n\t * @return {View|TileLayer}\n\t */\n\tview(v) {\n\t\treturn sb.prop(this, '_view', v);\n\t}\n\n\t/**\n\t * Setter / Getter de la largeur des zones.\n\t * On considère le monde infini. Une zone est une portion de ce monde infini.\n\t *\n\t * @param z {int=} largeur d'une zone\n\t * @return {object|Fairy.TileLayer}\n\t */\n\tzoneWidth(z) {\n\t\treturn sb.prop(this, '_zoneWidth', z);\n\t}\n\n\t/**\n\t * Setter / Getter de la hauteur des zones.\n\t * On considère le monde infini. Une zone est une portion de ce monde infini.\n\t *\n\t * @param z {int=} hauteur d'une zone\n\t * @return {int|Fairy.TileLayer}\n\t */\n\tzoneHeight(z) {\n\t\treturn sb.prop(this, '_zoneHeight', z);\n\t}\n\n\t/**\n\t * Setter / Getter de zones\n\t * C'est une collection de Zones : celle qui sont actuellement chargée et qui peuvent etre affichées à tout moement\n\t * Généralement cet accesseur n'est utilisé qu'en tant que getter.\n\t * @param o {object=} liste des zone\n\t * @return {object|Fairy.TileLayer}\n\t */\n\tzones(o) {\n\t\treturn sb.prop(this, '_zones', o);\n\t}\n\n\t/**\n\t * Setter / Getter du flag moreZone\n\t * Quand la fenetre de View penetre dans une zone, cela déclenche immédiatemennt un évènement\n\t * réclamenet le chargement de la zone. avec ce Flag l'évènement est déclenché pour toutes les zones contigues.\n\t * @param b {boolean=}\n\t * @return {boolean|Fairy.TileLayer}\n\t */\n\tmoreZones(b) {\n\t\treturn sb.prop(this, '_moreZone', b);\n\t}\n\n\t/**\n\t * Calcule la liste des zones balayées par la vue\n\t * Renvoi des évèbnements\n\t * zone.(a|d|n) {\n\t *\tx, coordonnée x de la portion\n\t *\ty, coordonnée y de la portion\n\t *\tkey, clé d'identification de la portion\n\t * \tcanvas: canvas/image qu'il faudra fournir en retour\n\t * }\n\t */\n\tupdate() {\n\t\tlet p = this.view().points();\n\t\tlet cw = this.zoneWidth();\n\t\tlet ch = this.zoneHeight();\n\t\tlet vx = p[0].x;\n\t\tlet vy = p[0].y;\n\t\tlet xs = Math.floor(vx / cw);\n\t\tlet ys = Math.floor(vy / ch);\n\t\tlet xe = Math.floor(p[1].x / cw);\n\t\tlet ye = Math.floor(p[1].y / ch);\n\t\tif (this.moreZones()) {\n\t\t\t--xs;\n\t\t\t--ys;\n\t\t\t++xe;\n\t\t\t++ye;\n\t\t}\n\t\tlet sKey, oNow = {};\n\t\tlet oPrev = this.zones();\n\t\tlet a = {\n\t\t\td: [], // zone à décharger (ne sert plus car sort de la zone de vue)\n\t\t\tn: [], // nouvelle zone à charger, vien d'apparaitre dans la vue\n\t\t\ta: [] // zone toucjourr affichée\n\t\t};\n\n\t\tfor (let x, y = ys; y <= ye; ++y) {\n\t\t\tfor (x = xs; x <= xe; ++x) {\n\t\t\t\tsKey = x.toString() + ':' + y.toString();\n\t\t\t\tif (oPrev[sKey]) {\n\t\t\t\t\ta.a.push(sKey);\n\t\t\t\t\toNow[sKey] = oPrev[sKey];\n\t\t\t\t\tdelete oPrev[sKey];\n\t\t\t\t} else {\n\t\t\t\t\t// ajout\n\t\t\t\t\toNow[sKey] = {\n\t\t\t\t\t\tx: x,\n\t\t\t\t\t\ty: y,\n\t\t\t\t\t\tkey: sKey,\n\t\t\t\t\t\tcanvas: null\n\t\t\t\t\t};\n\t\t\t\t\ta.n.push(sKey);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (sKey in oPrev) {\n\t\t\ta.d.push(sKey);\n\t\t}\n\t\tthis.zones(oNow);\n\t\tfor (let s in a) {\n\t\t\ta[s].forEach((function(key) {\n\t\t\t\tthis.trigger('zone.' + s, oNow[key]);\n\t\t\t}).bind(this));\n\t\t}\n\t\treturn this;\n\t}\n\n\ttrigger(sEvent, ...args) {\n\t\tconsole.log(sEvent, ...args);\n\t}\n\n\t/**\n\t * Rendu du layer\n\t * @param oContext {object}\n\t */\n\trender(oContext) {\n\t\tlet zc;\n\t\tlet z = this.zones();\n\t\tlet p = this.view().points();\n\t\tlet cw = this.zoneWidth();\n\t\tlet vx = p[0].x;\n\t\tlet vy = p[0].y;\n\t\tfor (let c in z) {\n\t\t\tzc = z[c];\n\t\t\tif (zc.canvas) {\n\t\t\t\toContext.drawImage(zc.canvas, zc.x * cw - vx, zc.y * cw - vy);\n\t\t\t}\n\t\t}\n\t}\n}\n\n","const Grid = require('./Grid');\nconst TileLayer = require('./TileLayer');\nconst Cache2D = require('./Cache2D');\n\nmodule.exports = {\n    Grid, TileLayer, Cache2D\n};"],"sourceRoot":""}